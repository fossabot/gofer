{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"about/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"about/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"about/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"about/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"quickstart/","text":"Getting started Install Todo","title":"Install"},{"location":"quickstart/#getting-started","text":"","title":"Getting started"},{"location":"quickstart/#install","text":"Todo","title":"Install"},{"location":"reference/","text":"Welcome to Reference References are defined in three sections. Skeleton-App - example app Go - The backend framework Frontend - the frontend implementation","title":"Welcome to Reference"},{"location":"reference/#welcome-to-reference","text":"References are defined in three sections. Skeleton-App - example app Go - The backend framework Frontend - the frontend implementation","title":"Welcome to Reference"},{"location":"reference/frontend/alert/","text":"Alert Will display a VSnackbar with the default settings Timeout 5000 and Btn true . TODO: config for the framework. A complete axios response can be passed. if a json.error message exists, it will be displayed. Alert modes Mode ALERT . SUCCESS ALERT . INFO ALERT . ERROR Trigger store . commit ( 'alert/' + ALERT . ERROR , \"Message\" )","title":"Alert"},{"location":"reference/frontend/alert/#alert","text":"Will display a VSnackbar with the default settings Timeout 5000 and Btn true . TODO: config for the framework. A complete axios response can be passed. if a json.error message exists, it will be displayed.","title":"Alert"},{"location":"reference/frontend/alert/#alert-modes","text":"Mode ALERT . SUCCESS ALERT . INFO ALERT . ERROR","title":"Alert modes"},{"location":"reference/frontend/alert/#trigger","text":"store . commit ( 'alert/' + ALERT . ERROR , \"Message\" )","title":"Trigger"},{"location":"reference/frontend/login/","text":"Login Env Login is using the env VUE_APP_BACKGROUND and VUE_APP_LOGO to display the images. These env must be set or an error will be shown. Translations Used translation keys: Keys APPLICATION . Name APPLICATION . Description COMMON . Login COMMON . Password COMMON . ErrLoginRequired COMMON . ErrPasswordRequired COMMON . ErrPasswordLength COMMON . Privacy COMMON . Impress User Service: Func Pattern Description login /login (POST) sends the param login and password to the backend. logout /logout (GET) calls the url and deletes the user storage.`","title":"Login"},{"location":"reference/frontend/login/#login","text":"","title":"Login"},{"location":"reference/frontend/login/#env","text":"Login is using the env VUE_APP_BACKGROUND and VUE_APP_LOGO to display the images. These env must be set or an error will be shown.","title":"Env"},{"location":"reference/frontend/login/#translations","text":"Used translation keys: Keys APPLICATION . Name APPLICATION . Description COMMON . Login COMMON . Password COMMON . ErrLoginRequired COMMON . ErrPasswordRequired COMMON . ErrPasswordLength COMMON . Privacy COMMON . Impress","title":"Translations"},{"location":"reference/frontend/login/#user-service","text":"Func Pattern Description login /login (POST) sends the param login and password to the backend. logout /logout (GET) calls the url and deletes the user storage.`","title":"User Service:"},{"location":"reference/go/auth/","text":"Auth Package auth provides a standard auth for your website. Custom auth providers can be added. Simply implement the auth.Interface New The New function requires the provider name as argument. Error will return if the provider was not registered or configure before. // Example of the memory cache provider provider , err := auth . New ( \"native\" ) ConfigureProvider Must be used to configure the provider on webserver start. Because there can be different providers with different configurations, a map is passed as second argument. Please see the provider section for the different configuration parameters. err := ConfigureProvider ( \"native\" , nil ) //... Config The config is predefined in Server.Configuration.Auth . Name Description BcryptCost bcrypt cost AllowedFailedLogin number of failed login attempts before the user gets locked. LockDuration defines how long a user should be locked before the next login attempt is allowed. (RFC3339 duration string) InactiveDuration the allowed duration between the last login and now (RFC3339 duration string) TokenDuration JWT token live time (RFC3339 duration string) RefreshTokenDuration Refresh token live time (RFC3339 duration string) Controller The auth.Controller can be used out of the box. All required routes can be added with the helper function auth.AddRoutes . If you need to extend the controller, simply embed it into your controller and extend the functions. Protocol A Protocol is added which loggs the following user actions: Login Enter wrong password Locked user Inactive user Refresh Token Refresh Token failed Logout Reset password If you need to add additional protocols, use the helper function AddProtocol(userID,key,value) Claim By default, the user claim which will be included in the jwt token looks like this. It can be fully customized but be aware to re-implement the jwt.CallbackGenerate and jwt.CallbackRefresh for your requirements. type Claim struct { jwt . Claim Provider string `json:\"provider\"` UserID int `json:\"id\"` Name string `json:\"name\"` Surname string `json:\"surname\"` Login string `json:\"login\"` Roles [] string `json:\"Roles\"` Options map [ string ] string `json:\"options\"` } JWT middleware There are two pre-defined callbacks for the jwt middleware JWTRefreshCallback and JWTGenerateCallback . Which can be used out of the box. RBAC middleware A pre-defined rbac middleware can be used out of the box. Providers Native The native provider will connect to the existing user database. It will add an user option password for the authentication. Create your own provider To create your own provider, you have to implement the auth.Interface . type Interface interface { Login ( p controller . Interface ) ( Schema , error ) Logout ( p controller . Interface ) error RecoverPassword ( p controller . Interface ) error } Use the init function to register your provider. The registered value must be of the type func(opt map[string]interface{}) (Interface, error) . // init register the superFastMemory provider. func init () { err := auth . Register ( \"yourProvider\" , func ( options map [ string ] interface {}) ( auth . Interface , error ) { return & yourProvider {}, nil }) if err != nil { panic ( err ) } } type yourProvider struct { } func ( n * Native ) Login ( c controller . Interface ) ( auth . Schema , error ) { //... } Schema A Schema is defined which must be used from all providers. Options will be saved in the user database (not yet implemented). The Login will be mapped with the local user database. type Schema struct { Provider string UID string Login string Name string Surname string Salutation string Options [] Option }","title":"Auth"},{"location":"reference/go/auth/#auth","text":"Package auth provides a standard auth for your website. Custom auth providers can be added. Simply implement the auth.Interface","title":"Auth"},{"location":"reference/go/auth/#new","text":"The New function requires the provider name as argument. Error will return if the provider was not registered or configure before. // Example of the memory cache provider provider , err := auth . New ( \"native\" )","title":"New"},{"location":"reference/go/auth/#configureprovider","text":"Must be used to configure the provider on webserver start. Because there can be different providers with different configurations, a map is passed as second argument. Please see the provider section for the different configuration parameters. err := ConfigureProvider ( \"native\" , nil ) //...","title":"ConfigureProvider"},{"location":"reference/go/auth/#config","text":"The config is predefined in Server.Configuration.Auth . Name Description BcryptCost bcrypt cost AllowedFailedLogin number of failed login attempts before the user gets locked. LockDuration defines how long a user should be locked before the next login attempt is allowed. (RFC3339 duration string) InactiveDuration the allowed duration between the last login and now (RFC3339 duration string) TokenDuration JWT token live time (RFC3339 duration string) RefreshTokenDuration Refresh token live time (RFC3339 duration string)","title":"Config"},{"location":"reference/go/auth/#controller","text":"The auth.Controller can be used out of the box. All required routes can be added with the helper function auth.AddRoutes . If you need to extend the controller, simply embed it into your controller and extend the functions.","title":"Controller"},{"location":"reference/go/auth/#protocol","text":"A Protocol is added which loggs the following user actions: Login Enter wrong password Locked user Inactive user Refresh Token Refresh Token failed Logout Reset password If you need to add additional protocols, use the helper function AddProtocol(userID,key,value)","title":"Protocol"},{"location":"reference/go/auth/#claim","text":"By default, the user claim which will be included in the jwt token looks like this. It can be fully customized but be aware to re-implement the jwt.CallbackGenerate and jwt.CallbackRefresh for your requirements. type Claim struct { jwt . Claim Provider string `json:\"provider\"` UserID int `json:\"id\"` Name string `json:\"name\"` Surname string `json:\"surname\"` Login string `json:\"login\"` Roles [] string `json:\"Roles\"` Options map [ string ] string `json:\"options\"` }","title":"Claim"},{"location":"reference/go/auth/#jwt-middleware","text":"There are two pre-defined callbacks for the jwt middleware JWTRefreshCallback and JWTGenerateCallback . Which can be used out of the box.","title":"JWT middleware"},{"location":"reference/go/auth/#rbac-middleware","text":"A pre-defined rbac middleware can be used out of the box.","title":"RBAC middleware"},{"location":"reference/go/auth/#providers","text":"","title":"Providers"},{"location":"reference/go/auth/#native","text":"The native provider will connect to the existing user database. It will add an user option password for the authentication.","title":"Native"},{"location":"reference/go/auth/#create-your-own-provider","text":"To create your own provider, you have to implement the auth.Interface . type Interface interface { Login ( p controller . Interface ) ( Schema , error ) Logout ( p controller . Interface ) error RecoverPassword ( p controller . Interface ) error } Use the init function to register your provider. The registered value must be of the type func(opt map[string]interface{}) (Interface, error) . // init register the superFastMemory provider. func init () { err := auth . Register ( \"yourProvider\" , func ( options map [ string ] interface {}) ( auth . Interface , error ) { return & yourProvider {}, nil }) if err != nil { panic ( err ) } } type yourProvider struct { } func ( n * Native ) Login ( c controller . Interface ) ( auth . Schema , error ) { //... }","title":"Create your own provider"},{"location":"reference/go/auth/#schema","text":"A Schema is defined which must be used from all providers. Options will be saved in the user database (not yet implemented). The Login will be mapped with the local user database. type Schema struct { Provider string UID string Login string Name string Surname string Salutation string Options [] Option }","title":"Schema"},{"location":"reference/go/cache/","text":"Cache Package cache provides a cache manager for any type that implements the cache.Interface . It is developer friendly, offers additional prefixing and functions for hit/miss statistics. Usage Inspired by the database/sql , this module is based on providers. You have to import the needed provider with a dash in front: This will only call the init function(s) of the package(s) and will register itself. For a full list of all available providers, see the providers section . import \"github.com/patrickascher/gofer/cache\" import _ \"github.com/patrickascher/gofer/cache/memory\" New The New function requires two arguments. First the name of the registered provider and a provider configuration. Each provider will have different configuration settings, please see the providers section for more details. Error will return if the provider was not found or registered before. // Example of the memory cache provider mem , err := cache . New ( cache . MEMORY , nil ) SetDefaultPrefix Set a default prefix for all cache items which will be set with cache.DefaultPrefix . mem . SetDefaultPrefix ( \"session\" ) SetDefaultExpiration Set a default expiration for all cache items which will be set with cache.DefaultExpiration . mem . SetDefaultExpiration ( 5 * time . Hour ) Exist Exist wraps the Get() function and will return a boolean instead of an error. exists := mem . Exist ( \"name\" ) // Boolean Get, Prefix, All Get one or more cached items. Error will return if the cache item / prefix does not exist. // get a single cached item. item , err := mem . Get ( cache . DefaultPrefix , \"name\" ) // (Item, error) // get all cached items with the prefix \"session\" item , err := mem . Prefix ( \"session\" ) // ([]Item, error) // get all cached items item , err := mem . All () // ([]Item, error) Set Set a cache item by prefix, name, value and expiration. Infinity live time If you need no expiration for a cache item, use cache.NoExpiration . // the managers default expiration time. err := mem . Set ( cache . DefaultPrefix , \"name\" , \"value\" , cache . DefaultExpiration ) // custom expiration time and prefix. err := mem . Set ( \"session\" , \"name\" , \"value\" , 5 * time . Hour ) // no expiration. err := mem . Set ( cache . DefaultPrefix , \"name\" , \"value\" , cache . NoExpiration ) Delete, DeletePrefix, DeleteAll Delete one or more cached items. Error will return if the cache item / prefix does not exist. // delete the item by key err := mem . Delete ( cache . DefaultPrefix , \"name\" ) // delete all items with the prefix \"session\" err := mem . DeletePrefix ( \"session\" ) // delete all cached items err := mem . DeleteAll () HitCount Statistics how often the cache item was hit. err := mem . HitCount ( cache . DefaultPrefix , \"user\" ) MissCount Statistics how often the cache item was missed. err := mem . MissCount ( cache . DefaultPrefix , \"user\" ) Providers All pre-defined providers: Memory A simple in memory cache. Name: cache.MEMORY Options: Option Description GCInterval time.Duration how often the GC should run in a loop. Usage: import \"github.com/patrickascher/gofer/cache\" import _ \"github.com/patrickascher/gofer/cache/memory\" mem , err := cache . Manager ( cache . MEMORY , nil ) Create your own provider To create your own provider, you have to implement the cache.Interface . type Interface interface { // Get returns an Item by its name. // Error must returns if it does not exist. Get ( name string ) ( Item , error ) // All cached items. // Must returns nil if the cache is empty. All () ([] Item , error ) // Set an item by its name, value and lifetime. // If cache.NoExpiration is set, the item should not get deleted. Set ( name string , value interface {}, exp time . Duration ) error // Delete a value by its name. // Error must return if it does not exist. Delete ( name string ) error // DeleteAll items. DeleteAll () error // GC will be called once as goroutine. // If the cache backend has its own garbage collector (redis, memcached, ...) just return void in this method. GC () } Use the init function to register your provider. The registered value must be of the type func(interface {}) (cache.Interface, error) . // init register the superFastMemory provider. func init () { err := cache . Register ( \"superFastMemory\" , New ) if err != nil { log . Fatal ( err ) } } // New creates a super-fast-memory type which implements the cache.Interface. func New ( opt interface {}) ( cm . Interface , error ) { //... return & superFastMemory {}, nil } Usage import \"github.com/patrickascher/gofer/cache\" import _ \"your/repo/cache/superFastMemory\" memoryProvider , err := cache . Manager ( \"superFastMemory\" , nil )","title":"Cache"},{"location":"reference/go/cache/#cache","text":"Package cache provides a cache manager for any type that implements the cache.Interface . It is developer friendly, offers additional prefixing and functions for hit/miss statistics.","title":"Cache"},{"location":"reference/go/cache/#usage","text":"Inspired by the database/sql , this module is based on providers. You have to import the needed provider with a dash in front: This will only call the init function(s) of the package(s) and will register itself. For a full list of all available providers, see the providers section . import \"github.com/patrickascher/gofer/cache\" import _ \"github.com/patrickascher/gofer/cache/memory\"","title":"Usage"},{"location":"reference/go/cache/#new","text":"The New function requires two arguments. First the name of the registered provider and a provider configuration. Each provider will have different configuration settings, please see the providers section for more details. Error will return if the provider was not found or registered before. // Example of the memory cache provider mem , err := cache . New ( cache . MEMORY , nil )","title":"New"},{"location":"reference/go/cache/#setdefaultprefix","text":"Set a default prefix for all cache items which will be set with cache.DefaultPrefix . mem . SetDefaultPrefix ( \"session\" )","title":"SetDefaultPrefix"},{"location":"reference/go/cache/#setdefaultexpiration","text":"Set a default expiration for all cache items which will be set with cache.DefaultExpiration . mem . SetDefaultExpiration ( 5 * time . Hour )","title":"SetDefaultExpiration"},{"location":"reference/go/cache/#exist","text":"Exist wraps the Get() function and will return a boolean instead of an error. exists := mem . Exist ( \"name\" ) // Boolean","title":"Exist"},{"location":"reference/go/cache/#get-prefix-all","text":"Get one or more cached items. Error will return if the cache item / prefix does not exist. // get a single cached item. item , err := mem . Get ( cache . DefaultPrefix , \"name\" ) // (Item, error) // get all cached items with the prefix \"session\" item , err := mem . Prefix ( \"session\" ) // ([]Item, error) // get all cached items item , err := mem . All () // ([]Item, error)","title":"Get, Prefix, All"},{"location":"reference/go/cache/#set","text":"Set a cache item by prefix, name, value and expiration. Infinity live time If you need no expiration for a cache item, use cache.NoExpiration . // the managers default expiration time. err := mem . Set ( cache . DefaultPrefix , \"name\" , \"value\" , cache . DefaultExpiration ) // custom expiration time and prefix. err := mem . Set ( \"session\" , \"name\" , \"value\" , 5 * time . Hour ) // no expiration. err := mem . Set ( cache . DefaultPrefix , \"name\" , \"value\" , cache . NoExpiration )","title":"Set"},{"location":"reference/go/cache/#delete-deleteprefix-deleteall","text":"Delete one or more cached items. Error will return if the cache item / prefix does not exist. // delete the item by key err := mem . Delete ( cache . DefaultPrefix , \"name\" ) // delete all items with the prefix \"session\" err := mem . DeletePrefix ( \"session\" ) // delete all cached items err := mem . DeleteAll ()","title":"Delete, DeletePrefix, DeleteAll"},{"location":"reference/go/cache/#hitcount","text":"Statistics how often the cache item was hit. err := mem . HitCount ( cache . DefaultPrefix , \"user\" )","title":"HitCount"},{"location":"reference/go/cache/#misscount","text":"Statistics how often the cache item was missed. err := mem . MissCount ( cache . DefaultPrefix , \"user\" )","title":"MissCount"},{"location":"reference/go/cache/#providers","text":"All pre-defined providers:","title":"Providers"},{"location":"reference/go/cache/#memory","text":"A simple in memory cache. Name: cache.MEMORY Options: Option Description GCInterval time.Duration how often the GC should run in a loop. Usage: import \"github.com/patrickascher/gofer/cache\" import _ \"github.com/patrickascher/gofer/cache/memory\" mem , err := cache . Manager ( cache . MEMORY , nil )","title":"Memory"},{"location":"reference/go/cache/#create-your-own-provider","text":"To create your own provider, you have to implement the cache.Interface . type Interface interface { // Get returns an Item by its name. // Error must returns if it does not exist. Get ( name string ) ( Item , error ) // All cached items. // Must returns nil if the cache is empty. All () ([] Item , error ) // Set an item by its name, value and lifetime. // If cache.NoExpiration is set, the item should not get deleted. Set ( name string , value interface {}, exp time . Duration ) error // Delete a value by its name. // Error must return if it does not exist. Delete ( name string ) error // DeleteAll items. DeleteAll () error // GC will be called once as goroutine. // If the cache backend has its own garbage collector (redis, memcached, ...) just return void in this method. GC () } Use the init function to register your provider. The registered value must be of the type func(interface {}) (cache.Interface, error) . // init register the superFastMemory provider. func init () { err := cache . Register ( \"superFastMemory\" , New ) if err != nil { log . Fatal ( err ) } } // New creates a super-fast-memory type which implements the cache.Interface. func New ( opt interface {}) ( cm . Interface , error ) { //... return & superFastMemory {}, nil } Usage import \"github.com/patrickascher/gofer/cache\" import _ \"your/repo/cache/superFastMemory\" memoryProvider , err := cache . Manager ( \"superFastMemory\" , nil )","title":"Create your own provider"},{"location":"reference/go/config/","text":"Config Package config provides a config manager for any type that implements the config.Interface . It will load the parsed values into a configuration struct. Supports JSON, TOML, YAML, HCL, INI, envfile and Java properties config files (viper provider). Every provider has its own options, please see the providers section for more details. It also offers automatically config reload if the underlaying file changes and offers a callback function. Usage Inspired by the database/sql , this module is based on providers. You have to import the needed provider with a dash in front: This will only call the init function(s) of the package(s) and will register itself. For a full list of all available providers, see the providers section . import \"github.com/patrickascher/gofer/config\" import _ \"github.com/patrickascher/gofer/config/viper\" // example for the viper provider Load type Config struct { Host string User string //.... } // provider options options := viper . Options { FileName : \"config.json\" , FilePath : \".\" , FileType : \"json\" } // config struct cfg := Config {} // Load the configuration. err = config . Load ( config . VIPER , & cfg , options ) // cfg will have the loaded values Providers All pre-defined providers: Viper A wrapper for viper . This provider can load JSON, TOML, YAML, HCL, INI, envfile and Java properties config files. A watcher can be added to reload the configuration file on changes. Additional callback can be set. !!! Info By default, the configuration struct will be updated if the config file changes. Name: config.VIPER Options: Option Description FileName string Name of the config file. Mandatory FileType string Type of the config file. Mandatory FilePath string Path of the config file. Use . for the working directory. Mandatory Watch bool Watch the config file for changes. WatchCallback func(cfg interface{}, viper *viper.Viper, e fsnotify.Event) Callback function which will be triggered if the watcher is activated and a file change happens. EnvPrefix string Env prefix. EnvAutomatic bool All env variables will be mapped if the config struct key exists. EnvBind []string Only the defined env variables will be mapped if they exist in the config struct. Usage: import \"github.com/patrickascher/gofer/config\" import _ \"github.com/patrickascher/gofer/config/viper\" type Config struct { Host string User string //.... } // options options := viper . Options { FileName : \"config.json\" , FilePath : \".\" , FileType : \"json\" , Watch : true , WatchCallback : fileChangedCallback } func fileChangedCallback ( cfg interface {}, viper * viper . Viper , e fsnotify . Event ){ // on change, do something } // config struct cfg := Config {} // Load the configuration. err = config . Load ( config . VIPER , & cfg , options ) // cfg will have the loaded values Create your own provider To create your own provider, you have to implement the config.Interface . type Interface interface { Parse ( config interface {}, options interface {}) error } Use the init function to register your provider. The registered value must be of the type config.Interface . // init register your config provider func init () { err := registry . Set ( \"your-config-provider\" , new ( yourProvider )) if err != nil { log . Fatal ( err ) } } type yourProvider struct {} // New creates a super-fast-memory type which implements the cache.Interface. func ( p * yourProvider ) Parse ( cfg interface {}, opt interface {}) error { // parse something } Usage import \"github.com/patrickascher/gofer/cache\" import _ \"your/repo/config/yourProvider\" type Config struct { Host string User string //... } // configuration struct cfg := Config {} // your provider options, if you dont need any, just add nil as argument. options := YourProviderOptions {} err := config . Load ( \"your-config-provider\" , & cfg , options )","title":"Config"},{"location":"reference/go/config/#config","text":"Package config provides a config manager for any type that implements the config.Interface . It will load the parsed values into a configuration struct. Supports JSON, TOML, YAML, HCL, INI, envfile and Java properties config files (viper provider). Every provider has its own options, please see the providers section for more details. It also offers automatically config reload if the underlaying file changes and offers a callback function.","title":"Config"},{"location":"reference/go/config/#usage","text":"Inspired by the database/sql , this module is based on providers. You have to import the needed provider with a dash in front: This will only call the init function(s) of the package(s) and will register itself. For a full list of all available providers, see the providers section . import \"github.com/patrickascher/gofer/config\" import _ \"github.com/patrickascher/gofer/config/viper\" // example for the viper provider","title":"Usage"},{"location":"reference/go/config/#load","text":"type Config struct { Host string User string //.... } // provider options options := viper . Options { FileName : \"config.json\" , FilePath : \".\" , FileType : \"json\" } // config struct cfg := Config {} // Load the configuration. err = config . Load ( config . VIPER , & cfg , options ) // cfg will have the loaded values","title":"Load"},{"location":"reference/go/config/#providers","text":"All pre-defined providers:","title":"Providers"},{"location":"reference/go/config/#viper","text":"A wrapper for viper . This provider can load JSON, TOML, YAML, HCL, INI, envfile and Java properties config files. A watcher can be added to reload the configuration file on changes. Additional callback can be set. !!! Info By default, the configuration struct will be updated if the config file changes. Name: config.VIPER Options: Option Description FileName string Name of the config file. Mandatory FileType string Type of the config file. Mandatory FilePath string Path of the config file. Use . for the working directory. Mandatory Watch bool Watch the config file for changes. WatchCallback func(cfg interface{}, viper *viper.Viper, e fsnotify.Event) Callback function which will be triggered if the watcher is activated and a file change happens. EnvPrefix string Env prefix. EnvAutomatic bool All env variables will be mapped if the config struct key exists. EnvBind []string Only the defined env variables will be mapped if they exist in the config struct. Usage: import \"github.com/patrickascher/gofer/config\" import _ \"github.com/patrickascher/gofer/config/viper\" type Config struct { Host string User string //.... } // options options := viper . Options { FileName : \"config.json\" , FilePath : \".\" , FileType : \"json\" , Watch : true , WatchCallback : fileChangedCallback } func fileChangedCallback ( cfg interface {}, viper * viper . Viper , e fsnotify . Event ){ // on change, do something } // config struct cfg := Config {} // Load the configuration. err = config . Load ( config . VIPER , & cfg , options ) // cfg will have the loaded values","title":"Viper"},{"location":"reference/go/config/#create-your-own-provider","text":"To create your own provider, you have to implement the config.Interface . type Interface interface { Parse ( config interface {}, options interface {}) error } Use the init function to register your provider. The registered value must be of the type config.Interface . // init register your config provider func init () { err := registry . Set ( \"your-config-provider\" , new ( yourProvider )) if err != nil { log . Fatal ( err ) } } type yourProvider struct {} // New creates a super-fast-memory type which implements the cache.Interface. func ( p * yourProvider ) Parse ( cfg interface {}, opt interface {}) error { // parse something } Usage import \"github.com/patrickascher/gofer/cache\" import _ \"your/repo/config/yourProvider\" type Config struct { Host string User string //... } // configuration struct cfg := Config {} // your provider options, if you dont need any, just add nil as argument. options := YourProviderOptions {} err := config . Load ( \"your-config-provider\" , & cfg , options )","title":"Create your own provider"},{"location":"reference/go/controller/","text":"Controller Package controller provides a controller / action based http.Handler for the router . A controller can have different renderer and is easy to extend. Data, redirects and errors can be set directly in the controller. A context with some helpers for the response and request is provided. Usage Controller can be easy extended and added as route. You only need to embed the controller.Base . type MyController struct { constroller . Base } func ( c MyController ) User (){ // logic } // add controller to router with the mapping HTTP GET calls MyController.User() myController := MyController {} err = r . AddSecureRoute ( router . NewRoute ( \"/user\" , & myController , router . NewMapping ([] string { http . MethodGet }, myController . User , nil ))) Initialize Initialize is used to set the struct reference. This is called automatically by the router. c := MyController {} c . Initialize ( & c ) Action Return the requested Action name. Name Returns the controller name incl. the package name. RenderType Returns the render type. Default json . SetRenderType Set a custom render type. Set Is a helper to set controller variables. It wraps the context.Response.SetValue . Error Is a helper to set an error. If an error ist set, all defined values will be deleted. It wraps the context.Response.Error . Redirect Redirect to an URL. On a redirect the old controller data will be lost. ServeHTTP Implements the http.Handler interface. It creates a new instance of the requested controller and creates a new context . It checks if a action name is available and checks if a function with that name exists and calls it. If not, an error will return. Between the Action and `Render call, it checks if the Browser is still connected. Otherwise the request will be cancelled. If the controller has no custom set Error , the Render function will be called. SetContext Set a context to the controller. Context Context provides some useful helper for the Request and Response . Request Body Returns the raw body data. SetBody Can be used to manipulate the body data. Localizer Returns the controller localizer. Pattern Returns the router url pattern. Example: http://example.com/user/1 will return /user/:id HTTPRequest Returns the original *http.Request . JWTClaim A helper to return the claim set by the request context. Method Returns the HTTP method in uppercase. Is Compares the given method with the request HTTP method. if r . Is ( http . MethodGet ){ //... } IsSecure Returns true if the request is https . IsGet Checks if the request is a http.MethodGet . IsPost Checks if the request is a http.MethodPost . IsPatch Checks if the request is a http.MethodPatch . IsPut Checks if the request is a http.MethodPut . IsDelete Checks if the request is a http.MethodDelete . Param Returns a parameter by key. It returns a []string because the underlying HTML input field could be an array. Error will return on internal error or if the key does not exist. p , err := r . Param ( \"user\" ) Params Returns all existing parameters. It returns a map[string][]string because the underlying HTML input field could be an array. Error will return on internal error. IP IP of the request. Proxy Return all IPs which are in the X-Forwarded-For header. Scheme Scheme (http/https) checks the X-Forwarded-Proto header. If that one is empty the URL.Scheme gets checked. If that is also empty the request TLS will be checked. Host Returns the host name. Port number will be removed. If no host info is available, localhost will return. https://example.com:8080/user?id=12#test will return example.com . Protocol Returns the protocol name, such as HTTP/1.1. URI Returns full request url with query string fragment. https://example.com:8080/user?id=12#test will return /user?id=12#test . URL Returns request url path without the query string and fragment. https://example.com:8080/user?id=12#test will return /user FullURL Returns the schema,host,port,uri. https://example.com:8080/user?id=12#test will return https://example.com:8080/user?id=12#test . Site Returns base site url as scheme://domain type without the port. https://example.com:8080/user?id=12#test will return https://example.com . Domain Is an alias for Host . Port Will return the port of the request. If it is empty, 80 will return as default. Referer Returns the Referer Header. Response Is a helper to set data and to render the content. A custom render provider can be created, simply implement the Renderer interface. SetValue Set a value by key/value pair. Value Value by the key. If the key does not exist, nil will return. Values Returns all defined values. ResetValues Reset all defined values. Writer Returns the *http.ResponseWriter . Render Render will render the content by the given render type. An error will return if the render provider does not exist or the renders write function returns one. Error Error will render the error message by the given render type. An error will return if the render provider does not exist or the renders error function returns one. Create your own render provider To create your own render provider, you have to implement the controller.Renderer interface. CheckBrowserCancellation, CallAction, HasError TODO docu, just added because of ther unexported interface and mocking problem. // Renderer interface for the render providers. type Renderer interface { Name () string Icon () string Write ( response * Response ) error Error ( response * Response , code int , err error ) error } Use the init function to register your provider. // init register your render provider func init () { //... err := controller . RegisterRenderer ( \"xml\" , newXmlRenderer ) if err != nil { log . Fatal ( err ) } } type xmlRenderer struct {} func newXmlRenderer () ( Renderer , error ) { return & xmlRenderer {}, nil } // ... render functions Usage import \"github.com/patrickascher/gofer/controller\" import _ \"your/repo/controller/renderer\" // somewhere in your controller c . SetRenderType ( \"xml\" )","title":"Controller"},{"location":"reference/go/controller/#controller","text":"Package controller provides a controller / action based http.Handler for the router . A controller can have different renderer and is easy to extend. Data, redirects and errors can be set directly in the controller. A context with some helpers for the response and request is provided.","title":"Controller"},{"location":"reference/go/controller/#usage","text":"Controller can be easy extended and added as route. You only need to embed the controller.Base . type MyController struct { constroller . Base } func ( c MyController ) User (){ // logic } // add controller to router with the mapping HTTP GET calls MyController.User() myController := MyController {} err = r . AddSecureRoute ( router . NewRoute ( \"/user\" , & myController , router . NewMapping ([] string { http . MethodGet }, myController . User , nil )))","title":"Usage"},{"location":"reference/go/controller/#initialize","text":"Initialize is used to set the struct reference. This is called automatically by the router. c := MyController {} c . Initialize ( & c )","title":"Initialize"},{"location":"reference/go/controller/#action","text":"Return the requested Action name.","title":"Action"},{"location":"reference/go/controller/#name","text":"Returns the controller name incl. the package name.","title":"Name"},{"location":"reference/go/controller/#rendertype","text":"Returns the render type. Default json .","title":"RenderType"},{"location":"reference/go/controller/#setrendertype","text":"Set a custom render type.","title":"SetRenderType"},{"location":"reference/go/controller/#set","text":"Is a helper to set controller variables. It wraps the context.Response.SetValue .","title":"Set"},{"location":"reference/go/controller/#error","text":"Is a helper to set an error. If an error ist set, all defined values will be deleted. It wraps the context.Response.Error .","title":"Error"},{"location":"reference/go/controller/#redirect","text":"Redirect to an URL. On a redirect the old controller data will be lost.","title":"Redirect"},{"location":"reference/go/controller/#servehttp","text":"Implements the http.Handler interface. It creates a new instance of the requested controller and creates a new context . It checks if a action name is available and checks if a function with that name exists and calls it. If not, an error will return. Between the Action and `Render call, it checks if the Browser is still connected. Otherwise the request will be cancelled. If the controller has no custom set Error , the Render function will be called.","title":"ServeHTTP"},{"location":"reference/go/controller/#setcontext","text":"Set a context to the controller.","title":"SetContext"},{"location":"reference/go/controller/#context","text":"Context provides some useful helper for the Request and Response .","title":"Context"},{"location":"reference/go/controller/#request","text":"","title":"Request"},{"location":"reference/go/controller/#body","text":"Returns the raw body data.","title":"Body"},{"location":"reference/go/controller/#setbody","text":"Can be used to manipulate the body data.","title":"SetBody"},{"location":"reference/go/controller/#localizer","text":"Returns the controller localizer.","title":"Localizer"},{"location":"reference/go/controller/#pattern","text":"Returns the router url pattern. Example: http://example.com/user/1 will return /user/:id","title":"Pattern"},{"location":"reference/go/controller/#httprequest","text":"Returns the original *http.Request .","title":"HTTPRequest"},{"location":"reference/go/controller/#jwtclaim","text":"A helper to return the claim set by the request context.","title":"JWTClaim"},{"location":"reference/go/controller/#method","text":"Returns the HTTP method in uppercase.","title":"Method"},{"location":"reference/go/controller/#is","text":"Compares the given method with the request HTTP method. if r . Is ( http . MethodGet ){ //... }","title":"Is"},{"location":"reference/go/controller/#issecure","text":"Returns true if the request is https .","title":"IsSecure"},{"location":"reference/go/controller/#isget","text":"Checks if the request is a http.MethodGet .","title":"IsGet"},{"location":"reference/go/controller/#ispost","text":"Checks if the request is a http.MethodPost .","title":"IsPost"},{"location":"reference/go/controller/#ispatch","text":"Checks if the request is a http.MethodPatch .","title":"IsPatch"},{"location":"reference/go/controller/#isput","text":"Checks if the request is a http.MethodPut .","title":"IsPut"},{"location":"reference/go/controller/#isdelete","text":"Checks if the request is a http.MethodDelete .","title":"IsDelete"},{"location":"reference/go/controller/#param","text":"Returns a parameter by key. It returns a []string because the underlying HTML input field could be an array. Error will return on internal error or if the key does not exist. p , err := r . Param ( \"user\" )","title":"Param"},{"location":"reference/go/controller/#params","text":"Returns all existing parameters. It returns a map[string][]string because the underlying HTML input field could be an array. Error will return on internal error.","title":"Params"},{"location":"reference/go/controller/#ip","text":"IP of the request.","title":"IP"},{"location":"reference/go/controller/#proxy","text":"Return all IPs which are in the X-Forwarded-For header.","title":"Proxy"},{"location":"reference/go/controller/#scheme","text":"Scheme (http/https) checks the X-Forwarded-Proto header. If that one is empty the URL.Scheme gets checked. If that is also empty the request TLS will be checked.","title":"Scheme"},{"location":"reference/go/controller/#host","text":"Returns the host name. Port number will be removed. If no host info is available, localhost will return. https://example.com:8080/user?id=12#test will return example.com .","title":"Host"},{"location":"reference/go/controller/#protocol","text":"Returns the protocol name, such as HTTP/1.1.","title":"Protocol"},{"location":"reference/go/controller/#uri","text":"Returns full request url with query string fragment. https://example.com:8080/user?id=12#test will return /user?id=12#test .","title":"URI"},{"location":"reference/go/controller/#url","text":"Returns request url path without the query string and fragment. https://example.com:8080/user?id=12#test will return /user","title":"URL"},{"location":"reference/go/controller/#fullurl","text":"Returns the schema,host,port,uri. https://example.com:8080/user?id=12#test will return https://example.com:8080/user?id=12#test .","title":"FullURL"},{"location":"reference/go/controller/#site","text":"Returns base site url as scheme://domain type without the port. https://example.com:8080/user?id=12#test will return https://example.com .","title":"Site"},{"location":"reference/go/controller/#domain","text":"Is an alias for Host .","title":"Domain"},{"location":"reference/go/controller/#port","text":"Will return the port of the request. If it is empty, 80 will return as default.","title":"Port"},{"location":"reference/go/controller/#referer","text":"Returns the Referer Header.","title":"Referer"},{"location":"reference/go/controller/#response","text":"Is a helper to set data and to render the content. A custom render provider can be created, simply implement the Renderer interface.","title":"Response"},{"location":"reference/go/controller/#setvalue","text":"Set a value by key/value pair.","title":"SetValue"},{"location":"reference/go/controller/#value","text":"Value by the key. If the key does not exist, nil will return.","title":"Value"},{"location":"reference/go/controller/#values","text":"Returns all defined values.","title":"Values"},{"location":"reference/go/controller/#resetvalues","text":"Reset all defined values.","title":"ResetValues"},{"location":"reference/go/controller/#writer","text":"Returns the *http.ResponseWriter .","title":"Writer"},{"location":"reference/go/controller/#render","text":"Render will render the content by the given render type. An error will return if the render provider does not exist or the renders write function returns one.","title":"Render"},{"location":"reference/go/controller/#error_1","text":"Error will render the error message by the given render type. An error will return if the render provider does not exist or the renders error function returns one.","title":"Error"},{"location":"reference/go/controller/#create-your-own-render-provider","text":"To create your own render provider, you have to implement the controller.Renderer interface.","title":"Create your own render provider"},{"location":"reference/go/controller/#checkbrowsercancellation-callaction-haserror","text":"TODO docu, just added because of ther unexported interface and mocking problem. // Renderer interface for the render providers. type Renderer interface { Name () string Icon () string Write ( response * Response ) error Error ( response * Response , code int , err error ) error } Use the init function to register your provider. // init register your render provider func init () { //... err := controller . RegisterRenderer ( \"xml\" , newXmlRenderer ) if err != nil { log . Fatal ( err ) } } type xmlRenderer struct {} func newXmlRenderer () ( Renderer , error ) { return & xmlRenderer {}, nil } // ... render functions Usage import \"github.com/patrickascher/gofer/controller\" import _ \"your/repo/controller/renderer\" // somewhere in your controller c . SetRenderType ( \"xml\" )","title":"CheckBrowserCancellation, CallAction, HasError"},{"location":"reference/go/grid/","text":"Grid The grid package converts any grid.Source into a CRUD backend. All primary-, foreign, references and polymorphic fields are removed by default Relation will be displayed depth max 1 at the moment. belongsTo and manyToMany will be select boxes on the frontend. Errors will be set as controller errors. Field validation will happen automatically on front- and backend. Frontend fields will be rendered automatically by field type. Developer friendly. Every source which implements the grid.Source can be used. Usage func ( c MyController ) User (){ g := grid . New ( c , grid . Orm ( model ), nil ) //... g . Render () } New Creates a new grid instance. The first argument must be the controller , the second is the grid.Source and the third is the grid.config which is optional. The grid will be cached, to avoid re-creating the grid fields. The cache key will be the configured grid ID. g := grid . New ( c , grid . Orm ( model ), nil ) Config The grid can be fully configured. If the configuration should be changed after init dynamically, the Scope.Config() can be used. Name Default Description ID controller:action Unique name for the grid. This is used as cache key. Title {ID}-title Title of the grid. Description {ID}-description Description of the grid. Policy orm.WHITELIST If the Policy is WHITELIST , the fields have to be set explicit. Exports csv , pdf Slice of names of render types. Action see ACTION Filter see FILTER Translation false If set to true, the title will be the orm namespace-title. same goes for the description. Action Name Default Description Right true Defines where the action (details,edit,delete) column should be displayed on the grid table. AllowDetails false Allow details mode. AllowCreate true Allow create mode. AllowUpdate true Allow update mode. AllowDelete true Allow delete mode. Filter Name Default Description Allow true Allow filter. ShowQuickFilter true Show the quick filter bar. ShowCustomFilter true Show the custom filter button/view. AllowedRowsPerPage -1 , 5 , 10 , 15 , 25 , 50 The allowed rows per page. DefaultRowsPerPage 15 Default rows per page. Mode The grid mode is defined by the http.Method and controller.Params . Mode http.Method Param grid.FeTable GET grid.FeFilter GET mode=filter grid.SrcCallback GET mode=callback grid.FeDetails GET mode=details grid.FeCreate GET mode=create grid.FeUpdate GET mode=update grid.FeExport GET mode=export grid.SrcCreate POST grid.SrcUpdate PUT grid.SrcDelete DELETE Field Will return the grid field by name. If the field does not exist, an empty field with an error will return. field := grid . Field ( \"ID\" ) A field can be configured by the following functions. Each function returns itself, this way it can be chained. If an error occures, the fields error will be set. Error will be handled in grid.Render . The configuration for SetPosition , SetTitle , SetDescription , SetRemove , SetHidden and SetView must be set with grid.NewValue() . Like this, values can be defined for different grid modes. grid . Field ( \"ID\" ). SetTitle ( grid . NewValue ( \"ID\" ). SetDetails ( \"Identifier\" )) // grid mode: table, update, create will have the title \"ID\" // and details will have the title \"Identifier\". Function available frontend Description Name , SetName x Will set the fields name. The name is used in the frontend as id. Primary , SetPrimary x Will define if the field is a primary key. Type , SetType x Defines the field type. Title , SetTitle x Will set the fields title. Description , SetDescription x Will set the fields description. Position , SetPosition x Will set the fields position. Removed , SetRemove x Will flag the field as removed. Hidden , SetHidden x Will set the field as hidden. View , SetView x Will set a custom frontend view component for the field. ReadOnly , SetReadOnly x Will set the field as read only. Sort , SetSort x Will allow the sorting of the field and set the condition field name. Filter , SetFilter x Will allow the filtering of the field and set the condition operator and field name. GroupAble , SetGroupAble x Will set the field as group able. Options , Option , SetOption x Will add a option for the field. Relation , SetRelation x Will define the field as relation Field Will return a field by name. If the field was not found, an field error will be set. (relation) Fields , SetFields x Will return all child fields. (relation) Error Will return the field error. Field types Name implemented in frontend Description Bool Checkbox Integer Input-Integer Float Input-Numeric Text Input-Text TextArea TextArea Time Input Date Datepicker DateTime Datepicker+Input Select Select MultiSelect Select belongsTo Select hasOne Inputs hasMany Inputs m2m Select Options Name value Description DecoratorOption string , boolean a field name can be used {{Name}}. If the second parameter is set to true, HTML will not be escaped in the frontend. Callbacks Name value Description Select ? TODO: Validate Scope The scope will return some helper functions. Source Will return the grid source. src := scrope . Source () Config Will return a pointer to the grid config. For dynamically configuration of the grid. cfg := scrope . Config () Fields Will return all configured grid fields. fields := scrope . Fields () PrimaryFields Will return all defined primary fields of the grid. primaryFields := scrope . PrimaryFields () Controller Will return the grid controller instance. ctrl := scrope . Controller () Render Will render the grid by the actual grid mode. Mode set in frontend data Description grid.SrcCallback data The source callback function is called. as first param the requested callback will be set as string. grid.SrcCreate The source create function is called. grid.SrcUpdate The source update function is called. grid.SrcDelete The condition first will be called to ensure the correct primary key. The source delete function is called. grid.FeTable pagination , head , data , config ConditionAll is called to create the condition. Add header/pagination if its not excluded by param. The source all function is called. Add config and result to the controller. call the defined render type. grid.FeExport head , data , config Same as FeTable but without the pagination and limit. grid.FeCreate head add header data. grid.FeDetails , grid.FeUpdate head , data add header data. call conditionFirst. fetch the entry by the given id and set the controller data. grid.FeFilter TODO Orm With the orm function an orm.Interface will be converted to a grid.Source and can be used out of the box. g := grid . New ( ctrl , grid . Orm ( model ), nil ) Source interface To create your own source, you have to implement the grid.Source . type Source interface { Cache () cache . Manager PreInit ( Grid ) error Init ( Grid ) error Fields ( Grid ) ([] Field , error ) UpdatedFields ( Grid ) error Callback ( string , Grid ) ( interface {}, error ) First ( condition . Condition , Grid ) ( interface {}, error ) All ( condition . Condition , Grid ) ( interface {}, error ) Create ( Grid ) ( interface {}, error ) Update ( Grid ) error Delete ( condition . Condition , Grid ) error Count ( condition . Condition , Grid ) ( int , error ) //Interface() interface{} }","title":"Grid"},{"location":"reference/go/grid/#grid","text":"The grid package converts any grid.Source into a CRUD backend. All primary-, foreign, references and polymorphic fields are removed by default Relation will be displayed depth max 1 at the moment. belongsTo and manyToMany will be select boxes on the frontend. Errors will be set as controller errors. Field validation will happen automatically on front- and backend. Frontend fields will be rendered automatically by field type. Developer friendly. Every source which implements the grid.Source can be used.","title":"Grid"},{"location":"reference/go/grid/#usage","text":"func ( c MyController ) User (){ g := grid . New ( c , grid . Orm ( model ), nil ) //... g . Render () }","title":"Usage"},{"location":"reference/go/grid/#new","text":"Creates a new grid instance. The first argument must be the controller , the second is the grid.Source and the third is the grid.config which is optional. The grid will be cached, to avoid re-creating the grid fields. The cache key will be the configured grid ID. g := grid . New ( c , grid . Orm ( model ), nil )","title":"New"},{"location":"reference/go/grid/#config","text":"The grid can be fully configured. If the configuration should be changed after init dynamically, the Scope.Config() can be used. Name Default Description ID controller:action Unique name for the grid. This is used as cache key. Title {ID}-title Title of the grid. Description {ID}-description Description of the grid. Policy orm.WHITELIST If the Policy is WHITELIST , the fields have to be set explicit. Exports csv , pdf Slice of names of render types. Action see ACTION Filter see FILTER Translation false If set to true, the title will be the orm namespace-title. same goes for the description. Action Name Default Description Right true Defines where the action (details,edit,delete) column should be displayed on the grid table. AllowDetails false Allow details mode. AllowCreate true Allow create mode. AllowUpdate true Allow update mode. AllowDelete true Allow delete mode. Filter Name Default Description Allow true Allow filter. ShowQuickFilter true Show the quick filter bar. ShowCustomFilter true Show the custom filter button/view. AllowedRowsPerPage -1 , 5 , 10 , 15 , 25 , 50 The allowed rows per page. DefaultRowsPerPage 15 Default rows per page.","title":"Config"},{"location":"reference/go/grid/#mode","text":"The grid mode is defined by the http.Method and controller.Params . Mode http.Method Param grid.FeTable GET grid.FeFilter GET mode=filter grid.SrcCallback GET mode=callback grid.FeDetails GET mode=details grid.FeCreate GET mode=create grid.FeUpdate GET mode=update grid.FeExport GET mode=export grid.SrcCreate POST grid.SrcUpdate PUT grid.SrcDelete DELETE","title":"Mode"},{"location":"reference/go/grid/#field","text":"Will return the grid field by name. If the field does not exist, an empty field with an error will return. field := grid . Field ( \"ID\" ) A field can be configured by the following functions. Each function returns itself, this way it can be chained. If an error occures, the fields error will be set. Error will be handled in grid.Render . The configuration for SetPosition , SetTitle , SetDescription , SetRemove , SetHidden and SetView must be set with grid.NewValue() . Like this, values can be defined for different grid modes. grid . Field ( \"ID\" ). SetTitle ( grid . NewValue ( \"ID\" ). SetDetails ( \"Identifier\" )) // grid mode: table, update, create will have the title \"ID\" // and details will have the title \"Identifier\". Function available frontend Description Name , SetName x Will set the fields name. The name is used in the frontend as id. Primary , SetPrimary x Will define if the field is a primary key. Type , SetType x Defines the field type. Title , SetTitle x Will set the fields title. Description , SetDescription x Will set the fields description. Position , SetPosition x Will set the fields position. Removed , SetRemove x Will flag the field as removed. Hidden , SetHidden x Will set the field as hidden. View , SetView x Will set a custom frontend view component for the field. ReadOnly , SetReadOnly x Will set the field as read only. Sort , SetSort x Will allow the sorting of the field and set the condition field name. Filter , SetFilter x Will allow the filtering of the field and set the condition operator and field name. GroupAble , SetGroupAble x Will set the field as group able. Options , Option , SetOption x Will add a option for the field. Relation , SetRelation x Will define the field as relation Field Will return a field by name. If the field was not found, an field error will be set. (relation) Fields , SetFields x Will return all child fields. (relation) Error Will return the field error. Field types Name implemented in frontend Description Bool Checkbox Integer Input-Integer Float Input-Numeric Text Input-Text TextArea TextArea Time Input Date Datepicker DateTime Datepicker+Input Select Select MultiSelect Select belongsTo Select hasOne Inputs hasMany Inputs m2m Select Options Name value Description DecoratorOption string , boolean a field name can be used {{Name}}. If the second parameter is set to true, HTML will not be escaped in the frontend. Callbacks Name value Description Select ? TODO: Validate","title":"Field"},{"location":"reference/go/grid/#scope","text":"The scope will return some helper functions.","title":"Scope"},{"location":"reference/go/grid/#source","text":"Will return the grid source. src := scrope . Source ()","title":"Source"},{"location":"reference/go/grid/#config_1","text":"Will return a pointer to the grid config. For dynamically configuration of the grid. cfg := scrope . Config ()","title":"Config"},{"location":"reference/go/grid/#fields","text":"Will return all configured grid fields. fields := scrope . Fields ()","title":"Fields"},{"location":"reference/go/grid/#primaryfields","text":"Will return all defined primary fields of the grid. primaryFields := scrope . PrimaryFields ()","title":"PrimaryFields"},{"location":"reference/go/grid/#controller","text":"Will return the grid controller instance. ctrl := scrope . Controller ()","title":"Controller"},{"location":"reference/go/grid/#render","text":"Will render the grid by the actual grid mode. Mode set in frontend data Description grid.SrcCallback data The source callback function is called. as first param the requested callback will be set as string. grid.SrcCreate The source create function is called. grid.SrcUpdate The source update function is called. grid.SrcDelete The condition first will be called to ensure the correct primary key. The source delete function is called. grid.FeTable pagination , head , data , config ConditionAll is called to create the condition. Add header/pagination if its not excluded by param. The source all function is called. Add config and result to the controller. call the defined render type. grid.FeExport head , data , config Same as FeTable but without the pagination and limit. grid.FeCreate head add header data. grid.FeDetails , grid.FeUpdate head , data add header data. call conditionFirst. fetch the entry by the given id and set the controller data. grid.FeFilter TODO","title":"Render"},{"location":"reference/go/grid/#orm","text":"With the orm function an orm.Interface will be converted to a grid.Source and can be used out of the box. g := grid . New ( ctrl , grid . Orm ( model ), nil )","title":"Orm"},{"location":"reference/go/grid/#source-interface","text":"To create your own source, you have to implement the grid.Source . type Source interface { Cache () cache . Manager PreInit ( Grid ) error Init ( Grid ) error Fields ( Grid ) ([] Field , error ) UpdatedFields ( Grid ) error Callback ( string , Grid ) ( interface {}, error ) First ( condition . Condition , Grid ) ( interface {}, error ) All ( condition . Condition , Grid ) ( interface {}, error ) Create ( Grid ) ( interface {}, error ) Update ( Grid ) error Delete ( condition . Condition , Grid ) error Count ( condition . Condition , Grid ) ( int , error ) //Interface() interface{} }","title":"Source interface"},{"location":"reference/go/install/","text":"Install go get github . com / patrickascher / gofer","title":"Install"},{"location":"reference/go/install/#install","text":"go get github . com / patrickascher / gofer","title":"Install"},{"location":"reference/go/logger/","text":"Logger The package logger provides an interface for logging. It wraps awesome existing go loggers with that interface. In that case, it is easy to change the log provider without breaking anything in your application. Additionally log level, fields, time duration or caller information can be added. Register To register a logger by your requirements, simple use the logger.Register function. The registered logger must implement the logger.Provider interface. This should be done in the init() function or any other early stage in your application. For a list of all existing provider see providers section . // Example of the memory cache provider logrus := logrus . New () // the wrapped logrus instance can be configured as needed. logrus . Instance . ReportCaller = true // register the logger under a defined name err = logrus . Register ( \"importLogger\" , logrus ) //... Usage Use Get() to get a registered logger instance. // get the logger log , err := logger . Get ( \"importLogger\" ) // set some default logger settings. log . SetCallerFields ( true ) log . SetLogLevel ( logger . TRACE ) // creates a new info log entry. log . Info ( \"something\" ) // log with some details log . WithFields ( logger . Fields { \"foo\" : \"bar\" }). Info ( \"something\" ) // log with timer ltimer := log . WithTimer () //.. some logic ltimer . Debug ( \"some time\" ) //Field \"duration\" is added with the required time. SetCallerFields If you call SetCallerFields on a logger instance, it will add the file name and line number as fields. Default it is set to false . The caller will be set global for this logger instance. log . SetCallerFields ( true ) SetLogLevel Defines the level where it should start logging. Available log levels are logger.TRACE , logger.DEBUG , logger.INFO , logger.WARNING , logger.ERROR and logger.PANIC . Default it is set to logger.DEBUG . The level will be set global for this logger instance. log . SetLogLevel ( logger . INFO ) Log Level The following log levels are available. log . Trace ( \"msg\" ) log . Debug ( \"msg\" ) log . Info ( \"msg\" ) log . Warning ( \"msg\" ) log . Error ( \"msg\" ) log . Panic ( \"msg\" ) WithFields Sometimes a log message is not enough and some additional information is required. Info WithFields will create a new instance. log . WithFields ( logger . Fields { \"foo\" : \"bar\" }). Info ( \"msg\" ) WithTimer Sometimes it is useful for debugging to see the required time of a function. WithTimer can be combined WithFields or vis-a-vis. Info WithTimer will create a new instance. ltimer := log . WithTimer () //... ltimer . Debug ( \"msg\" ) // a Field \"duration\" with the required time is added. // combinde with fields ltimer = log . WithFields ( logger . Fields ( \"foo\" : \"bar\" )). WithTimer () //... ltimer . Debug ( \"msg\" ) // a Field \"duration\" and \"foo\" is added. New Sometimes its useful to create a logger with slightly a different configuration. The new instance will inherit the setting of the parent logger by default. log , err := logger . Get ( \"importLogger\" ) log . SetCallerFields ( true ) log . SetLogLevel ( logger . WARNING ) // create a new instance and add different settings. log2 := log . New () log2 . SetCallFields ( false ) log2 . SetLogLevel ( logger . TRACE ) Providers All pre-defined providers: Logrus A wrapper for logrus . Package: github.com/patrickascher/gofer/logger/logrus Options: The original logrus struct can be accessed by the Instance field. Please check the github page for the documentation. Usage: import \"github.com/patrickascher/gofer/logger\" import \"github.com/patrickascher/gofer/logger/logrus\" logrusProvider := logrus . New () logrusProvider . Instance . ReportCaller = true // register the logger err := logger . Register ( \"logger-name\" , logrusProvider ) // somewhere in the application log , err := logger . Get ( \"logger-name\" ) Create your own provider To create your own provider, you have to implement the logger.Provider interface. type Provider interface { Log ( Entry ) } The registered value must be of the type logger.Provider . type MyLogger struct { } func ( ml * MyLogger ) Log ( Entry ){ // ... do something } // register the logger err := logger . Register ( \"my-logger\" , & MyLogger {}) // somewhere in the application log , err := logger . Get ( \"my-logger\" ) Entry The logger.Entry holds all information about the log message. type Entry struct { Level level Timestamp time . Time Message string Fields Fields }","title":"Logger"},{"location":"reference/go/logger/#logger","text":"The package logger provides an interface for logging. It wraps awesome existing go loggers with that interface. In that case, it is easy to change the log provider without breaking anything in your application. Additionally log level, fields, time duration or caller information can be added.","title":"Logger"},{"location":"reference/go/logger/#register","text":"To register a logger by your requirements, simple use the logger.Register function. The registered logger must implement the logger.Provider interface. This should be done in the init() function or any other early stage in your application. For a list of all existing provider see providers section . // Example of the memory cache provider logrus := logrus . New () // the wrapped logrus instance can be configured as needed. logrus . Instance . ReportCaller = true // register the logger under a defined name err = logrus . Register ( \"importLogger\" , logrus ) //...","title":"Register"},{"location":"reference/go/logger/#usage","text":"Use Get() to get a registered logger instance. // get the logger log , err := logger . Get ( \"importLogger\" ) // set some default logger settings. log . SetCallerFields ( true ) log . SetLogLevel ( logger . TRACE ) // creates a new info log entry. log . Info ( \"something\" ) // log with some details log . WithFields ( logger . Fields { \"foo\" : \"bar\" }). Info ( \"something\" ) // log with timer ltimer := log . WithTimer () //.. some logic ltimer . Debug ( \"some time\" ) //Field \"duration\" is added with the required time.","title":"Usage"},{"location":"reference/go/logger/#setcallerfields","text":"If you call SetCallerFields on a logger instance, it will add the file name and line number as fields. Default it is set to false . The caller will be set global for this logger instance. log . SetCallerFields ( true )","title":"SetCallerFields"},{"location":"reference/go/logger/#setloglevel","text":"Defines the level where it should start logging. Available log levels are logger.TRACE , logger.DEBUG , logger.INFO , logger.WARNING , logger.ERROR and logger.PANIC . Default it is set to logger.DEBUG . The level will be set global for this logger instance. log . SetLogLevel ( logger . INFO )","title":"SetLogLevel"},{"location":"reference/go/logger/#log-level","text":"The following log levels are available. log . Trace ( \"msg\" ) log . Debug ( \"msg\" ) log . Info ( \"msg\" ) log . Warning ( \"msg\" ) log . Error ( \"msg\" ) log . Panic ( \"msg\" )","title":"Log Level"},{"location":"reference/go/logger/#withfields","text":"Sometimes a log message is not enough and some additional information is required. Info WithFields will create a new instance. log . WithFields ( logger . Fields { \"foo\" : \"bar\" }). Info ( \"msg\" )","title":"WithFields"},{"location":"reference/go/logger/#withtimer","text":"Sometimes it is useful for debugging to see the required time of a function. WithTimer can be combined WithFields or vis-a-vis. Info WithTimer will create a new instance. ltimer := log . WithTimer () //... ltimer . Debug ( \"msg\" ) // a Field \"duration\" with the required time is added. // combinde with fields ltimer = log . WithFields ( logger . Fields ( \"foo\" : \"bar\" )). WithTimer () //... ltimer . Debug ( \"msg\" ) // a Field \"duration\" and \"foo\" is added.","title":"WithTimer"},{"location":"reference/go/logger/#new","text":"Sometimes its useful to create a logger with slightly a different configuration. The new instance will inherit the setting of the parent logger by default. log , err := logger . Get ( \"importLogger\" ) log . SetCallerFields ( true ) log . SetLogLevel ( logger . WARNING ) // create a new instance and add different settings. log2 := log . New () log2 . SetCallFields ( false ) log2 . SetLogLevel ( logger . TRACE )","title":"New"},{"location":"reference/go/logger/#providers","text":"All pre-defined providers:","title":"Providers"},{"location":"reference/go/logger/#logrus","text":"A wrapper for logrus . Package: github.com/patrickascher/gofer/logger/logrus Options: The original logrus struct can be accessed by the Instance field. Please check the github page for the documentation. Usage: import \"github.com/patrickascher/gofer/logger\" import \"github.com/patrickascher/gofer/logger/logrus\" logrusProvider := logrus . New () logrusProvider . Instance . ReportCaller = true // register the logger err := logger . Register ( \"logger-name\" , logrusProvider ) // somewhere in the application log , err := logger . Get ( \"logger-name\" )","title":"Logrus"},{"location":"reference/go/logger/#create-your-own-provider","text":"To create your own provider, you have to implement the logger.Provider interface. type Provider interface { Log ( Entry ) } The registered value must be of the type logger.Provider . type MyLogger struct { } func ( ml * MyLogger ) Log ( Entry ){ // ... do something } // register the logger err := logger . Register ( \"my-logger\" , & MyLogger {}) // somewhere in the application log , err := logger . Get ( \"my-logger\" )","title":"Create your own provider"},{"location":"reference/go/logger/#entry","text":"The logger.Entry holds all information about the log message. type Entry struct { Level level Timestamp time . Time Message string Fields Fields }","title":"Entry"},{"location":"reference/go/orm/","text":"Orm Package orm transfers a struct into an ORM by simple embedding the orm.Model . Relations hasOne , belongsTo , hasMany and m2m will be defined automatically / manually. Usage type User struct { orm . Model ID int Name string Surname string } user := User {} // initialize orm model err = user . Init ( & user ) if err != nil { //... } // scope for some helper - if needed scope , err := user . Scope () if err != nil { //... } // set data user . Name = \"John\" user . Surname = \"Doe\" // create entry err = user . Create () //.. Requirements / defaults: Database name, Table name, Builder and Cache must be set. [see Default] Model requires one or more primary keys. If the field ID exists, it will automatically be taken as primary key. Primary keys can be set manually via Tags. [see Tags] All fields and relations must be available on the database backend, or they must be defined as custom. Unique field names must be provided. If an embedded struct overwrites a field name or relation, an error will return. Fields are allowed with the following type string , bool uint int float and any type which implements the sql.Scanner and driver.Valuer interface. Relations are only set if they implement the orm.Interface , except it's defined as custom. First Will return the first found row. Error sql.ErrNoRows will return if no result was found. user := User {} err := user . Init ( & orm ) // ... // first without any condition err = user . First () // first with a condition (id=1 err = user . First ( condition . New (). SetWhere ( \"id = ?\" , 1 )) All Will return all rows by the given condition. For more details about the relation handling, see Strategy . No error will return if no result was found (TODO CHANGE? same logic as First?) user := User {} err := user . Init ( & orm ) // ... // all without any condition var users [] User err = user . All ( & user ) // all with a condition (id>10) err = user . All ( & user , condition . New (). SetWhere ( \"id > ?\" , 10 )) Count Count the existing rows by the given condition. user := User {} err := user . Init ( & orm ) // ... // count without any condition rows , err = user . Count () // count with a condition (id>10) rows , err = user . Count ( condition . New (). SetWhere ( \"id > ?\" , 10 )) Create Will create an entry. For more details about the relation handling, see Strategy . user := User {} err := user . Init ( & orm ) // ... user . Name = \"John\" user . Surname = \"Doe\" user . Phonenumbers = append ( user . Phonenumbers , \"000-111-222\" ) //has m err = user . Create () Update Will update an entry. For more details about the relation handling, see Strategy . A Snapshot will be taken and only changed values will be updated. user := User {} err := user . Init ( & orm ) // ... user . Name = \"Foo\" user . Surname = \"Bar\" err = user . Update () Delete Will delete an entry. For more details about the relation handling, see Strategy . user := User {} err := user . Init ( & orm ) // ... user . ID = 4 err = user . Delete () Permissions Like the permission tag see Tags , it's sometimes useful to dynamic set the policy and fields. Permissions sets the read/write permission for the given fields. This means you can allow or disallow single fields for saving / fetching. The field setting will overwrite the configured permission tag. Info Primary-, foreign-, reference and polykeys are always added. This means if an ID, which is a primary key gets blacklisted, the ID field will be removed from the blacklist automatically. // set field permission - only Name, Surname and all mandatory keys will be loaded. user . SetPermissions ( orm . WHITELIST , \"Name\" , \"Surname\" ) // read the configured permissions policy , fields := user . Permissions () Tags The orm struct fields can be simple configured by tags. The tag must be defined under the key orm For more details about the tags, see ParseTag Tag Description Values Example - Skips the complete struct field. orm:\"-\" custom Defines a field as a none sql field. orm:\"custom\" column Set a custom table column name name orm:\"column:name\" permission A field can be defined as Write or Read only. If the permission is empty read and write will be set to false . If a read permission is false, it the column will not be fetched by first and all. If a write permission is false, the column will not be saved on create or update. r,w or empty. orm:\"permission:rw\" sql Set a custom select for the column. Only supported for First and All . string orm:\"sql:CONCAT(name,surname)\" primary Defines a column as primary. orm:\"primary\" relation Defines a relation hasOne , belongsTo , hasMany , m2m orm:\"relations:belongsTo\" fk Defines a custom foreign key string orm:\"fk:CustomID\" refs Defines a custom references key. string orm:\"refs:UserID\" join_table Defines a custom join table name. string orm:\"join_table:user_mapping\" join_fk Defines a custom foreign column name for the junction table. string orm:\"join_fk:CustomID\" join_refs Defines a custom references column name for the junction table. string orm:\"join_refs:UserID\" poly Defines a custom poly name. string orm:\"poly:Toy\" poly_value Defines a custom poly value. string orm:\"poly:User\" Validation Validation for struct fields can be configured by tags. Under the hood the package validator is used. Struct fields validation can be defined by the tag validate . Please check out the validator documentation for all available tags. All query.NullTypes are registered and can be validated. Custom validation tags can be registered by orm.RegisterValidation(tag string, fn func(ctx context.Context, fl valid.FieldLevel) bool, callValidationEvenIfZero ...bool) . As context the orm.Interface will be set under the name orm.MODEL . Info The validation happens on orm.Create and orm.Update . Only on struct fields with write permission. type User struct { orm . Model Name `validate:\"required\"` Country `validate:\"country\"` } err := orm . RegisterValidation ( \"country\" , countryValidation ) if err != nil { // ... } func countryValidation ( ctx ctx . Context , fl valid . FieldLevel ) bool { model := ctx . Value ( orm . MODEL ).( orm . Interface ) // ... some checks return true } Defaults Struct defaults The orm can be simple customized by struct functions. func ( u User ) DefaultTableName (){ return \"users\" } Function Description Default Return Value DefaultCache A cache.Manager and time.Duration must be set. The time.Duration indicates how log the orm.Model should be cached. [see Cache] - cache.Manager , time.Duration DefaultBuilder A query.Builder must be set for the sql handling. [see Query] - query.Builder DefaultTableName The struct table name. Plural name of the struct in snake_case. string DefaultDatabaseName The struct database name. The query.Builder.Config().Database value. string DefaultStrategy The data fetching strategy. [see Strategy] eager string DefaultSoftDelete Soft deletion instead of deleting the complete db entry. [see SoftDelete] DeletedAt orm.SoftDelete SoftDelete By default, a db row will not get deleted, when a column deleted_at is available. The default value will be the actual timestamp. To change this behaviour, simple overwrite the DefaultSoftDelete function. In the example the db field status will be set with the value 1 and all rows with the value 0 are active. func ( y YourModel ) DefaultSoftDelete () SoftDelete { SoftDelete { Field : \"Status\" , Value : \"1\" , ActiveValues : [] interface {}{ \"0\" }} } Info If the soft delete field does not exist in the struct, an error will return on orm.Init() . Relations Warn Everything in Relations will be developer information and you can probably skip it. Info All default settings can be overwritten by tag. By default, relations will be defined by the struct type. struct will be by default a hasOne relation. slice will be by default a hasMany relation. slice self referencing will be by default a m2m relation HasOne, HasMany fk The foreign key will be the primary key of the orm model. refs The references will be the orm model name + ID on the relation model. poly The polymorphic is by default the relation orm name + ID (will be set as Refs) and name + Type. The value will be the orm model name. user User { ID int Adr Address { ID int UserID int Street string } } // fk = ID // refs = UserID or AddressID if poly is set. // poly = Address // poly_value = User BelongsTo fk The foreign key will be the relation orm model name + ID on the orm model. refs The relation orm model's primary key. poly The polymorphic is by default the relation orm name + ID (will be set as FK) and name + Type. The value will be the orm model name. user User { ID int AddressID Adr Address { ID int UserID int Street string } } // fk = AddressID // refs = ID or AddressID if poly is set. // poly = Address // poly_value = User ManyToMany fk The foreign key will be the primary key of the orm model. refs The references will be the primary key of the orm relation model. poly The polymorphic is by default the relation orm name + ID (will be set as Refs) and name + Type. The value will be the orm model name. join_table The orm model name + orm relation name in snake style and plural. join_fk The foreign key will be the orm model name + ID of the orm model. join_refs The references key will be the orm relation model name + ID of the orm relation model. It will be child_id on self referencing. user User { ID int AddressID Adr [] Address { ID int UserID int Street string } } // fk = ID // refs = ID // poly = Address // poly_value = User // join_table = user_addresses // join_fk = user_id // join_refs = address_id , child_id - on self referencing Scope The scope includes some helper functions for the orm model. Error will return if the orm model was not initialized yet. // ... scope , err := model . Scope () if err != nil { // ... } SetConfig Can be used to customize the relation or root orm model configuration. If no name is given, the scopes root will be set. // customizing a relation sql condition config := scope . SetConfig ( orm . NewConfig (). SetCondition ( condition . New (). SetWhere ( \"id>?\" , 10 ), true ), \"Address\" ) Field Default Description SetAllowHasOneZero true will trigger an error if a hasOne relation has no rows and its set to false. SetShowDeletedRows false will show/hide the deleted rows by the soft delete definitions. SetUpdateReferenceOnly false will only update the reference on belongsTo and m2m relations instead of updating the relation model. SetCondition add a sql condition. the condition can be merged with the defaults or replace them. Condition will return the defined condition Config Will return the defined orm model configuration. If no name is given, the scopes root configuration will be taken. config := scope . Config () Name Will return the name of the struct, with or without the package prefix. // with package name name := scope . Name ( true ) // without package name name = scope . Name ( true ) Builder Builder will return the model builder. builder := scope . Builder () FqdnTable Is a helper to display the models database and table name. table := scope . FqdnTable () FqdnModel Is a helper to display the model name and the field name. field := scope . FqdnModel ( \"Name\" ) // field: orm.User:Name Model Will return the scopes orm model. model := scope . Model () Caller Will return the orm model caller. caller := scope . Caller () Cache, SetCache Set or get the model cache. At the moment not in use because of the DefaultCache logic. TODO: Delete? SQLFields Will return all struct fields by permission as slice string. fields := scope . SQLFields ( Permission { Read : true }) SQLScanFields SQLScanFields is a helper for row.scan. It will scan the struct fields by the given permission. fields := scope . SQLScanFields ( Permission { Read : true }) SQLColumns Will return all struct fields by permission as slice string. cols := scope . SQLColumns ( Permission { Read : true }) Field Returns a ptr to the struct field by name. Error will return if the field does not exist. field , err := scope . Field ( \"Name\" ) FieldValue Returns a reflect.Value of the orm caller struct field. It returns the zero Value if no field was found. rv := scope . FieldValue ( \"Name\" ) SQLRelation Will return teh requested relation by permission. Relations(s) which are defined as \"custom\" or have not the required Permission will not be returned. Error will return if the relation does not exist or has not the required permission. relation , err := scope . SQLRelation ( \"Address\" , Permission { Read : true }) SQLRelations SQLRelations will return all sql relations by the given Permission. Relation(s) which are defined as \"custom\" or have not the required Permission will not be returned. relations := scope . SQLRelations ( Permission { Read : true }) PrimaryKeysSet Checks if all primaries have a non zero value. valid := scope . PrimaryKeysSet () PrimaryKeys Will return all defined primary keys of the struct. Error will return if none was defined. primaryFields , err := scope . PrimaryKeys () if err != nil { // ... } SoftDelete Will return the soft deleting struct. sd := scope . SoftDelete () Parent Parent returns the parent model by name or the root model if the name is empty. The name must be the orm struct name incl. namespace. Error will return if no parent exists or the given name does not exist. The max search depth is limited to 20. model , err := scope . Parent ( \"User\" ) SetParent scope . SetParent ( model ) IsEmpty Checks if all the orm model fields and relations are empty. valid := scope . IsEmpty ( Permission { Read : true }) IsSelfReferenceLoop IsSelfReferenceLoop checks if the model has a self reference loop. Animal (hasOne) -> Address (belongsTo) -> *Animal valid := scope . IsSelfReferenceLoop ( relation ) IsSelfReferencing IsSelfReferencing is a helper to check if the model caller has the same type as the given field type. Role.Roles (m2m) -> Role valid := scope . IsSelfReferenceLoop ( relation ) TakeSnapshot TakeSnapshot will define if a snapshot of the orm model will be taken. This is used mainly in update. AppendChangedValue AppendChangedValue adds the changedValue if it does not exist yet by the given field name. SetChangedValues SetChangedValues sets the changedValues field of the scope. This is used to pass the values to a child orm model. ChangedValueByFieldName ChangedValueByFieldName returns a *changedValue by the field name. Nil will return if it does not exist. InitRelationByField InitRelationByField will return the orm.Interface of the field. ptr * = if the value was nil, a new orm.Interface gets set, if its not nil, the value will be taken. struct = * of that struct ptr *[], [] = new orm.Interface InitRelation InitRelation initialize the given relation. The orm model parent will be set, config, permission list and tx will be passed. SetBackReference SetBackReference will set a backreference if detected. NewScopeFromType Will return a new scope of the given type. Strategy Every orm model can have its own loading strategy. By default eager is defined. Eager The eager loading strategy will load the root orm and all relations at once. It is possible to only load required data by setting the field/relation permissions. see Permissions . The following will describe the internal logic of the eager strategy. This information is only interesting for the framework contributors. First First will return one row by the given condition. If a soft delete field is defined, by default only the \"not soft deleted\" rows will be shown. This can be changed by config. If a HasOne relation returns no result, an error will return. This can be changed by config. Only fields with the read permission will be read. Error (sql.ErrNoRows) returns if First finds no rows. HasOne, BelongsTo: will call orm First(). HasMany, ManyToMany will call orm All(). All All rows by the given condition will be fetched. All foreign keys are collected after the main select, all relations are handled by one request to minimize the db queries. m2m has actual 3 selects to ensure a different db builder could be used. The data is mapped automatically afterwards. Only fields with the read permission will be read. TODO Back-Reference only works for First -> All calls at the moment. Create Create a new entry. BelongsTo: will be skipped on empty or if a self reference loop is detected. Otherwise the entry will be created and the reference field will be set. If the belongsTo primary key(s) are already set, it will update the entry instead of creating it (if the pkey exists in the db). There is an option to only update the reference field without creating or updating the linked entry. (belongsTo, manyToMany) Only fields with the write permission will be written. Field(s): will be created and the last inserted ID will be set to the model. HasOne: If the value is zero it will be skipped. The reference keys (fk and poly) will be set to the child orm and will be created. HasMany: If the value is zero it will be skipped. If the relations has no sub relations, a batch insert is made to limit the db queries. If relations exists, a normal Create will happen. In both cases, the reference keys (fk and poly) will be set to the child orm and will be created. ManyToMany: If the value is zero it will be skipped. If the primary key(s) are already set, it will update the entry instead of creating it (if the pkey exists in the db). The junction table will be filled automatically. There is an option to only update the reference field without creating or updating the linked entry. Update Update entry by the given condition. Only fields with the wrote permission will be written. There is an option to only update the reference field without creating or updating the linked entry. (BelongsTo, ManyToMany) Only changed values will be updated. A Snapshot over the whole orm is taken before. BelongsTo : CREATE: create or update (pk exist) the orm model. UPDATE: Update the parent orm model. DELETE: Only the reference is deleted at the moment. Field(s): gets updated if the value changed. HasOne: CREATE: set reference IDs to the child orm, delete old references (can happen if a user add manually a struct), create the new entry. UPDATE: set reference IDs to the child orm, update the child orm. DELETE: delete the child orm. (query deletion happens - performance, TODO: call orm.Delete() to ensure soft delete?) HasMany: CREATE: create the entries. UPDATE: the changed value entry is defined in the following categories. - CREATE: slice entries gets created. - UPDATE: slice entries gets updates. - DELETE: all IDs gets collected and will be deleted as batch to minimize the db queries. DELETE: entries will get deleted by query.(query deletion happens - performance, TODO: call orm.Delete() to ensure soft delete? ManyToMany: CREATE: Create or update (if pk is set and exists in db) the slice entry. the junction table will be batched to minimize the db queries. UPDATE: the changed value entry is defined in the following categories. - CREATE: slice entries gets created or updated (if pk is set and exists in db). the junction table will be batched. - UPDATE: the slice entry. - DELETE: collect all deleted entries. delete only in the junction table at the moment. the junction table will be batched. TODO: think about a strategy. DELETE: entries are only deleted by the junction table at the moment. TODO: think about a strategy. Create your own To create your own strategy, you have to implement the Strategy interface. type Strategy interface { First ( scope Scope , c condition . Condition , permission Permission ) error All ( res interface {}, scope Scope , c condition . Condition ) error Create ( scope Scope ) error Update ( scope Scope , c condition . Condition ) error Delete ( scope Scope , c condition . Condition ) error Load ( interface {}) Strategy } Use the init function to register your strategy by name The registered value must be of the type func(Strategy, error) . func init () { err := Register ( \"yourStrategy\" , newStrategy ) if err != nil { log . Fatal ( err ) } } // newEager returns the orm.Strategy. func newStrategy () ( Strategy , error ) { return & something {}, nil } Now you can can access the strategy from your orm model by defining the DefaultStrategy function with the required strategy.","title":"Orm"},{"location":"reference/go/orm/#orm","text":"Package orm transfers a struct into an ORM by simple embedding the orm.Model . Relations hasOne , belongsTo , hasMany and m2m will be defined automatically / manually.","title":"Orm"},{"location":"reference/go/orm/#usage","text":"type User struct { orm . Model ID int Name string Surname string } user := User {} // initialize orm model err = user . Init ( & user ) if err != nil { //... } // scope for some helper - if needed scope , err := user . Scope () if err != nil { //... } // set data user . Name = \"John\" user . Surname = \"Doe\" // create entry err = user . Create () //.. Requirements / defaults: Database name, Table name, Builder and Cache must be set. [see Default] Model requires one or more primary keys. If the field ID exists, it will automatically be taken as primary key. Primary keys can be set manually via Tags. [see Tags] All fields and relations must be available on the database backend, or they must be defined as custom. Unique field names must be provided. If an embedded struct overwrites a field name or relation, an error will return. Fields are allowed with the following type string , bool uint int float and any type which implements the sql.Scanner and driver.Valuer interface. Relations are only set if they implement the orm.Interface , except it's defined as custom.","title":"Usage"},{"location":"reference/go/orm/#first","text":"Will return the first found row. Error sql.ErrNoRows will return if no result was found. user := User {} err := user . Init ( & orm ) // ... // first without any condition err = user . First () // first with a condition (id=1 err = user . First ( condition . New (). SetWhere ( \"id = ?\" , 1 ))","title":"First"},{"location":"reference/go/orm/#all","text":"Will return all rows by the given condition. For more details about the relation handling, see Strategy . No error will return if no result was found (TODO CHANGE? same logic as First?) user := User {} err := user . Init ( & orm ) // ... // all without any condition var users [] User err = user . All ( & user ) // all with a condition (id>10) err = user . All ( & user , condition . New (). SetWhere ( \"id > ?\" , 10 ))","title":"All"},{"location":"reference/go/orm/#count","text":"Count the existing rows by the given condition. user := User {} err := user . Init ( & orm ) // ... // count without any condition rows , err = user . Count () // count with a condition (id>10) rows , err = user . Count ( condition . New (). SetWhere ( \"id > ?\" , 10 ))","title":"Count"},{"location":"reference/go/orm/#create","text":"Will create an entry. For more details about the relation handling, see Strategy . user := User {} err := user . Init ( & orm ) // ... user . Name = \"John\" user . Surname = \"Doe\" user . Phonenumbers = append ( user . Phonenumbers , \"000-111-222\" ) //has m err = user . Create ()","title":"Create"},{"location":"reference/go/orm/#update","text":"Will update an entry. For more details about the relation handling, see Strategy . A Snapshot will be taken and only changed values will be updated. user := User {} err := user . Init ( & orm ) // ... user . Name = \"Foo\" user . Surname = \"Bar\" err = user . Update ()","title":"Update"},{"location":"reference/go/orm/#delete","text":"Will delete an entry. For more details about the relation handling, see Strategy . user := User {} err := user . Init ( & orm ) // ... user . ID = 4 err = user . Delete ()","title":"Delete"},{"location":"reference/go/orm/#permissions","text":"Like the permission tag see Tags , it's sometimes useful to dynamic set the policy and fields. Permissions sets the read/write permission for the given fields. This means you can allow or disallow single fields for saving / fetching. The field setting will overwrite the configured permission tag. Info Primary-, foreign-, reference and polykeys are always added. This means if an ID, which is a primary key gets blacklisted, the ID field will be removed from the blacklist automatically. // set field permission - only Name, Surname and all mandatory keys will be loaded. user . SetPermissions ( orm . WHITELIST , \"Name\" , \"Surname\" ) // read the configured permissions policy , fields := user . Permissions ()","title":"Permissions"},{"location":"reference/go/orm/#tags","text":"The orm struct fields can be simple configured by tags. The tag must be defined under the key orm For more details about the tags, see ParseTag Tag Description Values Example - Skips the complete struct field. orm:\"-\" custom Defines a field as a none sql field. orm:\"custom\" column Set a custom table column name name orm:\"column:name\" permission A field can be defined as Write or Read only. If the permission is empty read and write will be set to false . If a read permission is false, it the column will not be fetched by first and all. If a write permission is false, the column will not be saved on create or update. r,w or empty. orm:\"permission:rw\" sql Set a custom select for the column. Only supported for First and All . string orm:\"sql:CONCAT(name,surname)\" primary Defines a column as primary. orm:\"primary\" relation Defines a relation hasOne , belongsTo , hasMany , m2m orm:\"relations:belongsTo\" fk Defines a custom foreign key string orm:\"fk:CustomID\" refs Defines a custom references key. string orm:\"refs:UserID\" join_table Defines a custom join table name. string orm:\"join_table:user_mapping\" join_fk Defines a custom foreign column name for the junction table. string orm:\"join_fk:CustomID\" join_refs Defines a custom references column name for the junction table. string orm:\"join_refs:UserID\" poly Defines a custom poly name. string orm:\"poly:Toy\" poly_value Defines a custom poly value. string orm:\"poly:User\"","title":"Tags"},{"location":"reference/go/orm/#validation","text":"Validation for struct fields can be configured by tags. Under the hood the package validator is used. Struct fields validation can be defined by the tag validate . Please check out the validator documentation for all available tags. All query.NullTypes are registered and can be validated. Custom validation tags can be registered by orm.RegisterValidation(tag string, fn func(ctx context.Context, fl valid.FieldLevel) bool, callValidationEvenIfZero ...bool) . As context the orm.Interface will be set under the name orm.MODEL . Info The validation happens on orm.Create and orm.Update . Only on struct fields with write permission. type User struct { orm . Model Name `validate:\"required\"` Country `validate:\"country\"` } err := orm . RegisterValidation ( \"country\" , countryValidation ) if err != nil { // ... } func countryValidation ( ctx ctx . Context , fl valid . FieldLevel ) bool { model := ctx . Value ( orm . MODEL ).( orm . Interface ) // ... some checks return true }","title":"Validation"},{"location":"reference/go/orm/#defaults","text":"","title":"Defaults"},{"location":"reference/go/orm/#struct-defaults","text":"The orm can be simple customized by struct functions. func ( u User ) DefaultTableName (){ return \"users\" } Function Description Default Return Value DefaultCache A cache.Manager and time.Duration must be set. The time.Duration indicates how log the orm.Model should be cached. [see Cache] - cache.Manager , time.Duration DefaultBuilder A query.Builder must be set for the sql handling. [see Query] - query.Builder DefaultTableName The struct table name. Plural name of the struct in snake_case. string DefaultDatabaseName The struct database name. The query.Builder.Config().Database value. string DefaultStrategy The data fetching strategy. [see Strategy] eager string DefaultSoftDelete Soft deletion instead of deleting the complete db entry. [see SoftDelete] DeletedAt orm.SoftDelete","title":"Struct defaults"},{"location":"reference/go/orm/#softdelete","text":"By default, a db row will not get deleted, when a column deleted_at is available. The default value will be the actual timestamp. To change this behaviour, simple overwrite the DefaultSoftDelete function. In the example the db field status will be set with the value 1 and all rows with the value 0 are active. func ( y YourModel ) DefaultSoftDelete () SoftDelete { SoftDelete { Field : \"Status\" , Value : \"1\" , ActiveValues : [] interface {}{ \"0\" }} } Info If the soft delete field does not exist in the struct, an error will return on orm.Init() .","title":"SoftDelete"},{"location":"reference/go/orm/#relations","text":"Warn Everything in Relations will be developer information and you can probably skip it. Info All default settings can be overwritten by tag. By default, relations will be defined by the struct type. struct will be by default a hasOne relation. slice will be by default a hasMany relation. slice self referencing will be by default a m2m relation","title":"Relations"},{"location":"reference/go/orm/#hasone-hasmany","text":"fk The foreign key will be the primary key of the orm model. refs The references will be the orm model name + ID on the relation model. poly The polymorphic is by default the relation orm name + ID (will be set as Refs) and name + Type. The value will be the orm model name. user User { ID int Adr Address { ID int UserID int Street string } } // fk = ID // refs = UserID or AddressID if poly is set. // poly = Address // poly_value = User","title":"HasOne, HasMany"},{"location":"reference/go/orm/#belongsto","text":"fk The foreign key will be the relation orm model name + ID on the orm model. refs The relation orm model's primary key. poly The polymorphic is by default the relation orm name + ID (will be set as FK) and name + Type. The value will be the orm model name. user User { ID int AddressID Adr Address { ID int UserID int Street string } } // fk = AddressID // refs = ID or AddressID if poly is set. // poly = Address // poly_value = User","title":"BelongsTo"},{"location":"reference/go/orm/#manytomany","text":"fk The foreign key will be the primary key of the orm model. refs The references will be the primary key of the orm relation model. poly The polymorphic is by default the relation orm name + ID (will be set as Refs) and name + Type. The value will be the orm model name. join_table The orm model name + orm relation name in snake style and plural. join_fk The foreign key will be the orm model name + ID of the orm model. join_refs The references key will be the orm relation model name + ID of the orm relation model. It will be child_id on self referencing. user User { ID int AddressID Adr [] Address { ID int UserID int Street string } } // fk = ID // refs = ID // poly = Address // poly_value = User // join_table = user_addresses // join_fk = user_id // join_refs = address_id , child_id - on self referencing","title":"ManyToMany"},{"location":"reference/go/orm/#scope","text":"The scope includes some helper functions for the orm model. Error will return if the orm model was not initialized yet. // ... scope , err := model . Scope () if err != nil { // ... }","title":"Scope"},{"location":"reference/go/orm/#setconfig","text":"Can be used to customize the relation or root orm model configuration. If no name is given, the scopes root will be set. // customizing a relation sql condition config := scope . SetConfig ( orm . NewConfig (). SetCondition ( condition . New (). SetWhere ( \"id>?\" , 10 ), true ), \"Address\" ) Field Default Description SetAllowHasOneZero true will trigger an error if a hasOne relation has no rows and its set to false. SetShowDeletedRows false will show/hide the deleted rows by the soft delete definitions. SetUpdateReferenceOnly false will only update the reference on belongsTo and m2m relations instead of updating the relation model. SetCondition add a sql condition. the condition can be merged with the defaults or replace them. Condition will return the defined condition","title":"SetConfig"},{"location":"reference/go/orm/#config","text":"Will return the defined orm model configuration. If no name is given, the scopes root configuration will be taken. config := scope . Config ()","title":"Config"},{"location":"reference/go/orm/#name","text":"Will return the name of the struct, with or without the package prefix. // with package name name := scope . Name ( true ) // without package name name = scope . Name ( true )","title":"Name"},{"location":"reference/go/orm/#builder","text":"Builder will return the model builder. builder := scope . Builder ()","title":"Builder"},{"location":"reference/go/orm/#fqdntable","text":"Is a helper to display the models database and table name. table := scope . FqdnTable ()","title":"FqdnTable"},{"location":"reference/go/orm/#fqdnmodel","text":"Is a helper to display the model name and the field name. field := scope . FqdnModel ( \"Name\" ) // field: orm.User:Name","title":"FqdnModel"},{"location":"reference/go/orm/#model","text":"Will return the scopes orm model. model := scope . Model ()","title":"Model"},{"location":"reference/go/orm/#caller","text":"Will return the orm model caller. caller := scope . Caller ()","title":"Caller"},{"location":"reference/go/orm/#cache-setcache","text":"Set or get the model cache. At the moment not in use because of the DefaultCache logic. TODO: Delete?","title":"Cache, SetCache"},{"location":"reference/go/orm/#sqlfields","text":"Will return all struct fields by permission as slice string. fields := scope . SQLFields ( Permission { Read : true })","title":"SQLFields"},{"location":"reference/go/orm/#sqlscanfields","text":"SQLScanFields is a helper for row.scan. It will scan the struct fields by the given permission. fields := scope . SQLScanFields ( Permission { Read : true })","title":"SQLScanFields"},{"location":"reference/go/orm/#sqlcolumns","text":"Will return all struct fields by permission as slice string. cols := scope . SQLColumns ( Permission { Read : true })","title":"SQLColumns"},{"location":"reference/go/orm/#field","text":"Returns a ptr to the struct field by name. Error will return if the field does not exist. field , err := scope . Field ( \"Name\" )","title":"Field"},{"location":"reference/go/orm/#fieldvalue","text":"Returns a reflect.Value of the orm caller struct field. It returns the zero Value if no field was found. rv := scope . FieldValue ( \"Name\" )","title":"FieldValue"},{"location":"reference/go/orm/#sqlrelation","text":"Will return teh requested relation by permission. Relations(s) which are defined as \"custom\" or have not the required Permission will not be returned. Error will return if the relation does not exist or has not the required permission. relation , err := scope . SQLRelation ( \"Address\" , Permission { Read : true })","title":"SQLRelation"},{"location":"reference/go/orm/#sqlrelations","text":"SQLRelations will return all sql relations by the given Permission. Relation(s) which are defined as \"custom\" or have not the required Permission will not be returned. relations := scope . SQLRelations ( Permission { Read : true })","title":"SQLRelations"},{"location":"reference/go/orm/#primarykeysset","text":"Checks if all primaries have a non zero value. valid := scope . PrimaryKeysSet ()","title":"PrimaryKeysSet"},{"location":"reference/go/orm/#primarykeys","text":"Will return all defined primary keys of the struct. Error will return if none was defined. primaryFields , err := scope . PrimaryKeys () if err != nil { // ... }","title":"PrimaryKeys"},{"location":"reference/go/orm/#softdelete_1","text":"Will return the soft deleting struct. sd := scope . SoftDelete ()","title":"SoftDelete"},{"location":"reference/go/orm/#parent","text":"Parent returns the parent model by name or the root model if the name is empty. The name must be the orm struct name incl. namespace. Error will return if no parent exists or the given name does not exist. The max search depth is limited to 20. model , err := scope . Parent ( \"User\" )","title":"Parent"},{"location":"reference/go/orm/#setparent","text":"scope . SetParent ( model )","title":"SetParent"},{"location":"reference/go/orm/#isempty","text":"Checks if all the orm model fields and relations are empty. valid := scope . IsEmpty ( Permission { Read : true })","title":"IsEmpty"},{"location":"reference/go/orm/#isselfreferenceloop","text":"IsSelfReferenceLoop checks if the model has a self reference loop. Animal (hasOne) -> Address (belongsTo) -> *Animal valid := scope . IsSelfReferenceLoop ( relation )","title":"IsSelfReferenceLoop"},{"location":"reference/go/orm/#isselfreferencing","text":"IsSelfReferencing is a helper to check if the model caller has the same type as the given field type. Role.Roles (m2m) -> Role valid := scope . IsSelfReferenceLoop ( relation )","title":"IsSelfReferencing"},{"location":"reference/go/orm/#takesnapshot","text":"TakeSnapshot will define if a snapshot of the orm model will be taken. This is used mainly in update.","title":"TakeSnapshot"},{"location":"reference/go/orm/#appendchangedvalue","text":"AppendChangedValue adds the changedValue if it does not exist yet by the given field name.","title":"AppendChangedValue"},{"location":"reference/go/orm/#setchangedvalues","text":"SetChangedValues sets the changedValues field of the scope. This is used to pass the values to a child orm model.","title":"SetChangedValues"},{"location":"reference/go/orm/#changedvaluebyfieldname","text":"ChangedValueByFieldName returns a *changedValue by the field name. Nil will return if it does not exist.","title":"ChangedValueByFieldName"},{"location":"reference/go/orm/#initrelationbyfield","text":"InitRelationByField will return the orm.Interface of the field. ptr * = if the value was nil, a new orm.Interface gets set, if its not nil, the value will be taken. struct = * of that struct ptr *[], [] = new orm.Interface","title":"InitRelationByField"},{"location":"reference/go/orm/#initrelation","text":"InitRelation initialize the given relation. The orm model parent will be set, config, permission list and tx will be passed.","title":"InitRelation"},{"location":"reference/go/orm/#setbackreference","text":"SetBackReference will set a backreference if detected.","title":"SetBackReference"},{"location":"reference/go/orm/#newscopefromtype","text":"Will return a new scope of the given type.","title":"NewScopeFromType"},{"location":"reference/go/orm/#strategy","text":"Every orm model can have its own loading strategy. By default eager is defined.","title":"Strategy"},{"location":"reference/go/orm/#eager","text":"The eager loading strategy will load the root orm and all relations at once. It is possible to only load required data by setting the field/relation permissions. see Permissions . The following will describe the internal logic of the eager strategy. This information is only interesting for the framework contributors.","title":"Eager"},{"location":"reference/go/orm/#first_1","text":"First will return one row by the given condition. If a soft delete field is defined, by default only the \"not soft deleted\" rows will be shown. This can be changed by config. If a HasOne relation returns no result, an error will return. This can be changed by config. Only fields with the read permission will be read. Error (sql.ErrNoRows) returns if First finds no rows. HasOne, BelongsTo: will call orm First(). HasMany, ManyToMany will call orm All().","title":"First"},{"location":"reference/go/orm/#all_1","text":"All rows by the given condition will be fetched. All foreign keys are collected after the main select, all relations are handled by one request to minimize the db queries. m2m has actual 3 selects to ensure a different db builder could be used. The data is mapped automatically afterwards. Only fields with the read permission will be read. TODO Back-Reference only works for First -> All calls at the moment.","title":"All"},{"location":"reference/go/orm/#create_1","text":"Create a new entry. BelongsTo: will be skipped on empty or if a self reference loop is detected. Otherwise the entry will be created and the reference field will be set. If the belongsTo primary key(s) are already set, it will update the entry instead of creating it (if the pkey exists in the db). There is an option to only update the reference field without creating or updating the linked entry. (belongsTo, manyToMany) Only fields with the write permission will be written. Field(s): will be created and the last inserted ID will be set to the model. HasOne: If the value is zero it will be skipped. The reference keys (fk and poly) will be set to the child orm and will be created. HasMany: If the value is zero it will be skipped. If the relations has no sub relations, a batch insert is made to limit the db queries. If relations exists, a normal Create will happen. In both cases, the reference keys (fk and poly) will be set to the child orm and will be created. ManyToMany: If the value is zero it will be skipped. If the primary key(s) are already set, it will update the entry instead of creating it (if the pkey exists in the db). The junction table will be filled automatically. There is an option to only update the reference field without creating or updating the linked entry.","title":"Create"},{"location":"reference/go/orm/#update_1","text":"Update entry by the given condition. Only fields with the wrote permission will be written. There is an option to only update the reference field without creating or updating the linked entry. (BelongsTo, ManyToMany) Only changed values will be updated. A Snapshot over the whole orm is taken before. BelongsTo : CREATE: create or update (pk exist) the orm model. UPDATE: Update the parent orm model. DELETE: Only the reference is deleted at the moment. Field(s): gets updated if the value changed. HasOne: CREATE: set reference IDs to the child orm, delete old references (can happen if a user add manually a struct), create the new entry. UPDATE: set reference IDs to the child orm, update the child orm. DELETE: delete the child orm. (query deletion happens - performance, TODO: call orm.Delete() to ensure soft delete?) HasMany: CREATE: create the entries. UPDATE: the changed value entry is defined in the following categories. - CREATE: slice entries gets created. - UPDATE: slice entries gets updates. - DELETE: all IDs gets collected and will be deleted as batch to minimize the db queries. DELETE: entries will get deleted by query.(query deletion happens - performance, TODO: call orm.Delete() to ensure soft delete? ManyToMany: CREATE: Create or update (if pk is set and exists in db) the slice entry. the junction table will be batched to minimize the db queries. UPDATE: the changed value entry is defined in the following categories. - CREATE: slice entries gets created or updated (if pk is set and exists in db). the junction table will be batched. - UPDATE: the slice entry. - DELETE: collect all deleted entries. delete only in the junction table at the moment. the junction table will be batched. TODO: think about a strategy. DELETE: entries are only deleted by the junction table at the moment. TODO: think about a strategy.","title":"Update"},{"location":"reference/go/orm/#create-your-own","text":"To create your own strategy, you have to implement the Strategy interface. type Strategy interface { First ( scope Scope , c condition . Condition , permission Permission ) error All ( res interface {}, scope Scope , c condition . Condition ) error Create ( scope Scope ) error Update ( scope Scope , c condition . Condition ) error Delete ( scope Scope , c condition . Condition ) error Load ( interface {}) Strategy } Use the init function to register your strategy by name The registered value must be of the type func(Strategy, error) . func init () { err := Register ( \"yourStrategy\" , newStrategy ) if err != nil { log . Fatal ( err ) } } // newEager returns the orm.Strategy. func newStrategy () ( Strategy , error ) { return & something {}, nil } Now you can can access the strategy from your orm model by defining the DefaultStrategy function with the required strategy.","title":"Create your own"},{"location":"reference/go/query/","text":"Query The package query provides a simple programmatically sql query builder. The idea was to create a unique query builder which can be used with any database driver in go - with minimal effort. Features: Unique Placeholder for all database drivers Batching function for large Inserts Whitelist automatic quote of column and table names. SQL queries and durations log debugging Usage Inspired by the database/sql , this module is also based on providers. You have to import the needed provider with a dash in front: This will only call the init function(s) of the package(s) and will register itself. For a full list of all available providers, see the providers section . import \"github.com/patrickascher/gofer/query\" import _ \"github.com/patrickascher/gofer/query/mysql\" New To create a builder instance, you have to call New() with the needed provider name and configuration. Please see the providers section for a full list. builder , err := query . New ( \"mysql\" , query . Config {}) SetLogger A logger.Manager logger can be added to the builder. If one is defined, all queries will be logged on DEBUG level. builder . SetLogger ( logManager ) Config Will return the query.Config . builder . Config () QuoteIdentifier Will quote an identifier by the providers quote tags. name := builder . QuoteIdentifier ( \"test\" ) // on mysql name will be `test` Null types The following null type are defined for dealing with nullable SQL and JSON values. Following helper functions are defined NewNullString(string,valid) , NewNullBool(bool,valid) , NewNullInt(int64,valid) , NewNullFloat(float64,valid) and NewNullTime(time.Time,valid) . !!! info It' s a type alias for https://pkg.go.dev/github.com/guregu/null query.NullString query.NullBool query.NullInt query.NullFloat query.NullTime SanitizeValue SanitizeValue is a helper which converts: int , int8 , int16 , int32 , int64 , uint , uint8 , uint16 , uint32 , uint64 , query.NullInt to int64 string , query.NullString to string Error will return if the argument is not of the described types, or a NullType is not valid. value , err := query . SanitizeValue ( 1 ) // value will be int64(1) and err will be nil Query To create any query you have to call the query function builder . Query () Select Columns Columns define a fixed column order for the insert. If the columns are not set manually, * will be used. Only Values will be inserted which are defined here. This means, you can use Columns as a whitelist. b . Query (). Select ( \"test\" ). Column ( \"name\" , \"surname\" ) Condition Condition adds your own condition to the query. c := condition . New (). SetWhere ( \"id = ?\" , 1 ) b . Query (). Select ( \"test\" ). Condition ( c ) Join Join wraps the condition.SetJoin() function. For more details see condition section . b . Query (). Select ( \"test\" ). Join ( condition . LEFT , \"test_relation\" , \"test.id = test_relation\" ) Where Where wraps the condition.SetWhere() function. For more details see condition section . b . Query (). Select ( \"test\" ). Where ( \"id = ?\" , 1 ) Group Group wraps the condition.SetGroup() function. For more details see condition section . b . Query (). Select ( \"test\" ). Group ( \"name\" , \"surname\" ) Having Having wraps the condition.SetHaving() function. For more details see condition section . b . Query (). Select ( \"test\" ). Having ( \"id = ?\" , 1 ) Order Order wraps the condition.SetOrder() function. For more details see condition section . b . Query (). Select ( \"test\" ). Order ( \"name\" , \"-surname\" ) Limit Limit wraps the condition.SetLimit() function. For more details see condition section . b . Query (). Select ( \"test\" ). Limit ( 10 ) Offset Offset wraps the condition.SetOffset() function. For more details see condition section . b . Query (). Select ( \"test\" ). Offset ( 20 ) String String returns the rendered statement and arguments. sql , args , err := b . Query (). Select ( \"test\" ). String () First First will return a sql.Row. row , err := b . Query (). Select ( \"test\" ). Column ( \"name\" , \"surname\" ). First () // SELECT `name`, `surname` FROM test All All will return sql.Rows. res , err := b . Query (). Select ( \"test\" ). Column ( \"name\" , \"surname\" ). All () // SELECT `name`, `surname` FROM test Insert Batch Batch sets the batching size. Default batching size is 50. b . Query (). Insert ( \"test\" ). Batch ( 20 ) Columns Columns define a fixed column order for the insert. If the columns are not set manually, all keys of the Values will be added. Only Values will be inserted which are defined here. This means, you can use Columns as a whitelist. b . Query (). Insert ( \"test\" ). Columns ( \"name\" ) Values Values sets the insert data. values := [] map [ string ] interface {}{{ \"name\" : \"John\" }} b . Query (). Insert ( \"test\" ). Columns ( \"name\" ). Values ( values ) LastInsertedID LastInsertedID gets the last id over different drivers. The first argument must be a ptr to the value field. The second argument should be the name of the ID column - if needed. var id int b . Query (). Insert ( \"test\" ). Columns ( \"name\" ). LastInsertedID ( & id ) String String returns the rendered statement and arguments. values := [] map [ string ] interface {}{{ \"name\" : \"John\" }} b . Query (). Insert ( \"test\" ). Columns ( \"name\" ). Values ( values ). String () Exec Exec the statement. It will return a slice of []sql.Result because it could have been batched. values := [] map [ string ] interface {}{{ \"name\" : \"John\" }} res , err := b . Query (). Insert ( \"test\" ). Columns ( \"name\" ). Values ( values ). Exec () Update Columns Columns define a fixed column order for the insert. If the columns are not set manually, all keys of the Values will be added. Only Values will be inserted which are defined here. This means, you can use Columns as a whitelist. b . Query (). Update ( \"test\" ). Columns ( \"name\" ) Set Set the values. b . Query (). Update ( \"test\" ). Set ( map [ string ] interface {}{ \"name\" : \"John\" }) Where Where wraps the condition.SetWhere() function. For more details see condition section . b . Query (). Update ( \"test\" ). Set ( map [ string ] interface {}{ \"name\" : \"John\" }). Where ( \"id = ?\" , 1 ) Condition Condition adds your own condition to the query. c := condition . New (). SetWhere ( \"id = ?\" , 1 ) b . Query (). Update ( \"test\" ). Set ( map [ string ] interface {}{ \"name\" : \"John\" }). Condition ( c ) String String returns the rendered statement and arguments. sql , args , err := b . Query (). Update ( \"test\" ). Set ( map [ string ] interface {}{ \"name\" : \"John\" }). String () Exec Exec the statement. It will return a sql.Result . res , err := b . Query (). Update ( \"test\" ). Set ( map [ string ] interface {}{ \"name\" : \"John\" }). Exec () Delete Where Where wraps the condition.SetWhere() function. For more details see condition section . b . Query (). Delete ( \"test\" ). Where ( \"id = ?\" , 1 ) Condition Condition adds your own condition to the query. c := condition . New (). SetWhere ( \"id = ?\" , 1 ) b . Query (). Delete ( \"test\" ). Condition ( c ) String String returns the rendered statement and arguments. sql , args , err := b . Query (). Delete ( \"test\" ). String () Exec Exec the statement. It will return a sql.Result . res , err := b . Query (). Delete ( \"test\" ). Exec () Information Describe Describe the defined table. // all columns cols , err := b . Query (). Information ( \"test\" ). Describe () // only some columns cols , err := b . Query (). Information ( \"test\" ). Describe ( \"name\" , \"surname\" ) ForeignKey ForeignKey will return the foreign keys for the defined table. fks , err := b . Query (). Information ( \"test\" ). ForeignKey () DbExpr DBExpr is a helper to avoid quoting. Every string which is wrapped in query.DbExrp(\"test\") will not get quoted by the builder. Condition Condition provides a sql condition builder. The placeholder ? must be used and will automatically replaced with the driver placeholder later on. New Will create a new condition instance. c := condition . New () SetJoin, Join SetJoin will create a sql JOIN condition. LEFT , RIGHT , INNER and CROSS are supported. SQL USING() is not supported at the moment. If the join type is unknown or the table is empty, an error will be set. c . SetJoin ( condition . LEFT , \"users\" , \"users.id = ?\" , 1 ) Join will return the defined conditions as condition.Clause . On a clause, you can receive the condition and passed arguments. clauses := c . Join () clause [ 0 ]. Condition () // would return `JOIN LEFT users ON users.id = ?` clause [ 0 ]. Arguments () // would return `[]int{1}` SetWhere, Where SetWhere will create a sql WHERE condition. When called multiple times, its getting chained by AND operator. Arrays and slices can be passed as argument. c . SetWhere ( \"id = ? AND name = ?\" , 1 , \"John\" ) c . SetWhere ( \"id IN (?)\" ,[] int { 10 , 11 , 12 }) // will render the condition into `id IN (?, ?, ?)` Where will return the defined conditions as condition.Clause . On a clause, you can receive the condition and passed arguments. clauses := c . Where () clause [ 1 ]. Condition () // would return `id IN (?, ?, ?)` clause [ 1 ]. Arguments () // would return `[]int{10,11,12}` SetGroup, Group SetGroup should only be called once. If it's called more often, the last values are set. c . SetGroup ( \"id\" , \"name\" ) Group will return a slice of a string with all the added values. SetHaving, Having SetHaving and Having have the same functionality as SetWhere and Where . SetOrder, Order SetOrder should only be called once. If a column has a - prefix, DESC order will get set. If it's called more often, the last values are set. c . SetOrder ( \"name\" , \"-surname\" ) // rendered into `ORDER BY name ASC, surname DESC` SetLimit, Limit Set or get the sql LIMIT . c . SetLimit ( 10 ) SetOffset, Offset Set or get the sql OFFSET . c . SetOffset ( 2 ) Reset Reset the complete condition or only single parts. // complete condition will be reset. c . Reset () // only the WHERE conditions will be reset. c . Reset ( condition . Where ) Merge Merge two conditions. Group , Offset , Limit and Order will be set if they have a none zero value instead of merged, because they should only be used once. Where , Having and Join will be merged, if exist. a := conditon . New () // ... b := condition . New () // ... a . Merge ( b ) ReplacePlaceholders ReplacePlaceholders is a helper function to replace the condition.Placholder ? with any other placeholder. condition . ReplacePlaceholders ( \"id = ? AND name = ?\" , Placeholder { Char : \"$\" , Numeric : true }) // will return `id = $1 AND name = $2` Config The basic sql config is required. If a provider needs some additional configuration, its no problem to embed this struct but the providers function Config() must return this struct. type Config struct { Username string Password string Host string Port int Database string MaxIdleConnections int MaxOpenConnections int MaxConnLifetime time . Duration Timeout string PreQuery [] string } Providers Mysql Mysql Provider which uses github.com/go-sql-driver/mysql under the hood. Time structs will be parsed and a timeout limit is set to 30s by default. Usage: import \"github.com/patrickascher/gofer/query\" import _ \"github.com/patrickascher/gofer/query/mysql\" query . New ( \"mysql\" , config )","title":"Query"},{"location":"reference/go/query/#query","text":"The package query provides a simple programmatically sql query builder. The idea was to create a unique query builder which can be used with any database driver in go - with minimal effort. Features: Unique Placeholder for all database drivers Batching function for large Inserts Whitelist automatic quote of column and table names. SQL queries and durations log debugging","title":"Query"},{"location":"reference/go/query/#usage","text":"Inspired by the database/sql , this module is also based on providers. You have to import the needed provider with a dash in front: This will only call the init function(s) of the package(s) and will register itself. For a full list of all available providers, see the providers section . import \"github.com/patrickascher/gofer/query\" import _ \"github.com/patrickascher/gofer/query/mysql\"","title":"Usage"},{"location":"reference/go/query/#new","text":"To create a builder instance, you have to call New() with the needed provider name and configuration. Please see the providers section for a full list. builder , err := query . New ( \"mysql\" , query . Config {})","title":"New"},{"location":"reference/go/query/#setlogger","text":"A logger.Manager logger can be added to the builder. If one is defined, all queries will be logged on DEBUG level. builder . SetLogger ( logManager )","title":"SetLogger"},{"location":"reference/go/query/#config","text":"Will return the query.Config . builder . Config ()","title":"Config"},{"location":"reference/go/query/#quoteidentifier","text":"Will quote an identifier by the providers quote tags. name := builder . QuoteIdentifier ( \"test\" ) // on mysql name will be `test`","title":"QuoteIdentifier"},{"location":"reference/go/query/#null-types","text":"The following null type are defined for dealing with nullable SQL and JSON values. Following helper functions are defined NewNullString(string,valid) , NewNullBool(bool,valid) , NewNullInt(int64,valid) , NewNullFloat(float64,valid) and NewNullTime(time.Time,valid) . !!! info It' s a type alias for https://pkg.go.dev/github.com/guregu/null query.NullString query.NullBool query.NullInt query.NullFloat query.NullTime","title":"Null types"},{"location":"reference/go/query/#sanitizevalue","text":"SanitizeValue is a helper which converts: int , int8 , int16 , int32 , int64 , uint , uint8 , uint16 , uint32 , uint64 , query.NullInt to int64 string , query.NullString to string Error will return if the argument is not of the described types, or a NullType is not valid. value , err := query . SanitizeValue ( 1 ) // value will be int64(1) and err will be nil","title":"SanitizeValue"},{"location":"reference/go/query/#query_1","text":"To create any query you have to call the query function builder . Query ()","title":"Query"},{"location":"reference/go/query/#select","text":"","title":"Select"},{"location":"reference/go/query/#columns","text":"Columns define a fixed column order for the insert. If the columns are not set manually, * will be used. Only Values will be inserted which are defined here. This means, you can use Columns as a whitelist. b . Query (). Select ( \"test\" ). Column ( \"name\" , \"surname\" )","title":"Columns"},{"location":"reference/go/query/#condition","text":"Condition adds your own condition to the query. c := condition . New (). SetWhere ( \"id = ?\" , 1 ) b . Query (). Select ( \"test\" ). Condition ( c )","title":"Condition"},{"location":"reference/go/query/#join","text":"Join wraps the condition.SetJoin() function. For more details see condition section . b . Query (). Select ( \"test\" ). Join ( condition . LEFT , \"test_relation\" , \"test.id = test_relation\" )","title":"Join"},{"location":"reference/go/query/#where","text":"Where wraps the condition.SetWhere() function. For more details see condition section . b . Query (). Select ( \"test\" ). Where ( \"id = ?\" , 1 )","title":"Where"},{"location":"reference/go/query/#group","text":"Group wraps the condition.SetGroup() function. For more details see condition section . b . Query (). Select ( \"test\" ). Group ( \"name\" , \"surname\" )","title":"Group"},{"location":"reference/go/query/#having","text":"Having wraps the condition.SetHaving() function. For more details see condition section . b . Query (). Select ( \"test\" ). Having ( \"id = ?\" , 1 )","title":"Having"},{"location":"reference/go/query/#order","text":"Order wraps the condition.SetOrder() function. For more details see condition section . b . Query (). Select ( \"test\" ). Order ( \"name\" , \"-surname\" )","title":"Order"},{"location":"reference/go/query/#limit","text":"Limit wraps the condition.SetLimit() function. For more details see condition section . b . Query (). Select ( \"test\" ). Limit ( 10 )","title":"Limit"},{"location":"reference/go/query/#offset","text":"Offset wraps the condition.SetOffset() function. For more details see condition section . b . Query (). Select ( \"test\" ). Offset ( 20 )","title":"Offset"},{"location":"reference/go/query/#string","text":"String returns the rendered statement and arguments. sql , args , err := b . Query (). Select ( \"test\" ). String ()","title":"String"},{"location":"reference/go/query/#first","text":"First will return a sql.Row. row , err := b . Query (). Select ( \"test\" ). Column ( \"name\" , \"surname\" ). First () // SELECT `name`, `surname` FROM test","title":"First"},{"location":"reference/go/query/#all","text":"All will return sql.Rows. res , err := b . Query (). Select ( \"test\" ). Column ( \"name\" , \"surname\" ). All () // SELECT `name`, `surname` FROM test","title":"All"},{"location":"reference/go/query/#insert","text":"","title":"Insert"},{"location":"reference/go/query/#batch","text":"Batch sets the batching size. Default batching size is 50. b . Query (). Insert ( \"test\" ). Batch ( 20 )","title":"Batch"},{"location":"reference/go/query/#columns_1","text":"Columns define a fixed column order for the insert. If the columns are not set manually, all keys of the Values will be added. Only Values will be inserted which are defined here. This means, you can use Columns as a whitelist. b . Query (). Insert ( \"test\" ). Columns ( \"name\" )","title":"Columns"},{"location":"reference/go/query/#values","text":"Values sets the insert data. values := [] map [ string ] interface {}{{ \"name\" : \"John\" }} b . Query (). Insert ( \"test\" ). Columns ( \"name\" ). Values ( values )","title":"Values"},{"location":"reference/go/query/#lastinsertedid","text":"LastInsertedID gets the last id over different drivers. The first argument must be a ptr to the value field. The second argument should be the name of the ID column - if needed. var id int b . Query (). Insert ( \"test\" ). Columns ( \"name\" ). LastInsertedID ( & id )","title":"LastInsertedID"},{"location":"reference/go/query/#string_1","text":"String returns the rendered statement and arguments. values := [] map [ string ] interface {}{{ \"name\" : \"John\" }} b . Query (). Insert ( \"test\" ). Columns ( \"name\" ). Values ( values ). String ()","title":"String"},{"location":"reference/go/query/#exec","text":"Exec the statement. It will return a slice of []sql.Result because it could have been batched. values := [] map [ string ] interface {}{{ \"name\" : \"John\" }} res , err := b . Query (). Insert ( \"test\" ). Columns ( \"name\" ). Values ( values ). Exec ()","title":"Exec"},{"location":"reference/go/query/#update","text":"","title":"Update"},{"location":"reference/go/query/#columns_2","text":"Columns define a fixed column order for the insert. If the columns are not set manually, all keys of the Values will be added. Only Values will be inserted which are defined here. This means, you can use Columns as a whitelist. b . Query (). Update ( \"test\" ). Columns ( \"name\" )","title":"Columns"},{"location":"reference/go/query/#set","text":"Set the values. b . Query (). Update ( \"test\" ). Set ( map [ string ] interface {}{ \"name\" : \"John\" })","title":"Set"},{"location":"reference/go/query/#where_1","text":"Where wraps the condition.SetWhere() function. For more details see condition section . b . Query (). Update ( \"test\" ). Set ( map [ string ] interface {}{ \"name\" : \"John\" }). Where ( \"id = ?\" , 1 )","title":"Where"},{"location":"reference/go/query/#condition_1","text":"Condition adds your own condition to the query. c := condition . New (). SetWhere ( \"id = ?\" , 1 ) b . Query (). Update ( \"test\" ). Set ( map [ string ] interface {}{ \"name\" : \"John\" }). Condition ( c )","title":"Condition"},{"location":"reference/go/query/#string_2","text":"String returns the rendered statement and arguments. sql , args , err := b . Query (). Update ( \"test\" ). Set ( map [ string ] interface {}{ \"name\" : \"John\" }). String ()","title":"String"},{"location":"reference/go/query/#exec_1","text":"Exec the statement. It will return a sql.Result . res , err := b . Query (). Update ( \"test\" ). Set ( map [ string ] interface {}{ \"name\" : \"John\" }). Exec ()","title":"Exec"},{"location":"reference/go/query/#delete","text":"","title":"Delete"},{"location":"reference/go/query/#where_2","text":"Where wraps the condition.SetWhere() function. For more details see condition section . b . Query (). Delete ( \"test\" ). Where ( \"id = ?\" , 1 )","title":"Where"},{"location":"reference/go/query/#condition_2","text":"Condition adds your own condition to the query. c := condition . New (). SetWhere ( \"id = ?\" , 1 ) b . Query (). Delete ( \"test\" ). Condition ( c )","title":"Condition"},{"location":"reference/go/query/#string_3","text":"String returns the rendered statement and arguments. sql , args , err := b . Query (). Delete ( \"test\" ). String ()","title":"String"},{"location":"reference/go/query/#exec_2","text":"Exec the statement. It will return a sql.Result . res , err := b . Query (). Delete ( \"test\" ). Exec ()","title":"Exec"},{"location":"reference/go/query/#information","text":"","title":"Information"},{"location":"reference/go/query/#describe","text":"Describe the defined table. // all columns cols , err := b . Query (). Information ( \"test\" ). Describe () // only some columns cols , err := b . Query (). Information ( \"test\" ). Describe ( \"name\" , \"surname\" )","title":"Describe"},{"location":"reference/go/query/#foreignkey","text":"ForeignKey will return the foreign keys for the defined table. fks , err := b . Query (). Information ( \"test\" ). ForeignKey ()","title":"ForeignKey"},{"location":"reference/go/query/#dbexpr","text":"DBExpr is a helper to avoid quoting. Every string which is wrapped in query.DbExrp(\"test\") will not get quoted by the builder.","title":"DbExpr"},{"location":"reference/go/query/#condition_3","text":"Condition provides a sql condition builder. The placeholder ? must be used and will automatically replaced with the driver placeholder later on.","title":"Condition"},{"location":"reference/go/query/#new_1","text":"Will create a new condition instance. c := condition . New ()","title":"New"},{"location":"reference/go/query/#setjoin-join","text":"SetJoin will create a sql JOIN condition. LEFT , RIGHT , INNER and CROSS are supported. SQL USING() is not supported at the moment. If the join type is unknown or the table is empty, an error will be set. c . SetJoin ( condition . LEFT , \"users\" , \"users.id = ?\" , 1 ) Join will return the defined conditions as condition.Clause . On a clause, you can receive the condition and passed arguments. clauses := c . Join () clause [ 0 ]. Condition () // would return `JOIN LEFT users ON users.id = ?` clause [ 0 ]. Arguments () // would return `[]int{1}`","title":"SetJoin, Join"},{"location":"reference/go/query/#setwhere-where","text":"SetWhere will create a sql WHERE condition. When called multiple times, its getting chained by AND operator. Arrays and slices can be passed as argument. c . SetWhere ( \"id = ? AND name = ?\" , 1 , \"John\" ) c . SetWhere ( \"id IN (?)\" ,[] int { 10 , 11 , 12 }) // will render the condition into `id IN (?, ?, ?)` Where will return the defined conditions as condition.Clause . On a clause, you can receive the condition and passed arguments. clauses := c . Where () clause [ 1 ]. Condition () // would return `id IN (?, ?, ?)` clause [ 1 ]. Arguments () // would return `[]int{10,11,12}`","title":"SetWhere, Where"},{"location":"reference/go/query/#setgroup-group","text":"SetGroup should only be called once. If it's called more often, the last values are set. c . SetGroup ( \"id\" , \"name\" ) Group will return a slice of a string with all the added values.","title":"SetGroup, Group"},{"location":"reference/go/query/#sethaving-having","text":"SetHaving and Having have the same functionality as SetWhere and Where .","title":"SetHaving, Having"},{"location":"reference/go/query/#setorder-order","text":"SetOrder should only be called once. If a column has a - prefix, DESC order will get set. If it's called more often, the last values are set. c . SetOrder ( \"name\" , \"-surname\" ) // rendered into `ORDER BY name ASC, surname DESC`","title":"SetOrder, Order"},{"location":"reference/go/query/#setlimit-limit","text":"Set or get the sql LIMIT . c . SetLimit ( 10 )","title":"SetLimit, Limit"},{"location":"reference/go/query/#setoffset-offset","text":"Set or get the sql OFFSET . c . SetOffset ( 2 )","title":"SetOffset, Offset"},{"location":"reference/go/query/#reset","text":"Reset the complete condition or only single parts. // complete condition will be reset. c . Reset () // only the WHERE conditions will be reset. c . Reset ( condition . Where )","title":"Reset"},{"location":"reference/go/query/#merge","text":"Merge two conditions. Group , Offset , Limit and Order will be set if they have a none zero value instead of merged, because they should only be used once. Where , Having and Join will be merged, if exist. a := conditon . New () // ... b := condition . New () // ... a . Merge ( b )","title":"Merge"},{"location":"reference/go/query/#replaceplaceholders","text":"ReplacePlaceholders is a helper function to replace the condition.Placholder ? with any other placeholder. condition . ReplacePlaceholders ( \"id = ? AND name = ?\" , Placeholder { Char : \"$\" , Numeric : true }) // will return `id = $1 AND name = $2`","title":"ReplacePlaceholders"},{"location":"reference/go/query/#config_1","text":"The basic sql config is required. If a provider needs some additional configuration, its no problem to embed this struct but the providers function Config() must return this struct. type Config struct { Username string Password string Host string Port int Database string MaxIdleConnections int MaxOpenConnections int MaxConnLifetime time . Duration Timeout string PreQuery [] string }","title":"Config"},{"location":"reference/go/query/#providers","text":"","title":"Providers"},{"location":"reference/go/query/#mysql","text":"Mysql Provider which uses github.com/go-sql-driver/mysql under the hood. Time structs will be parsed and a timeout limit is set to 30s by default.","title":"Mysql"},{"location":"reference/go/query/#usage_1","text":"import \"github.com/patrickascher/gofer/query\" import _ \"github.com/patrickascher/gofer/query/mysql\" query . New ( \"mysql\" , config )","title":"Usage:"},{"location":"reference/go/registry/","text":"Registry Package registry provides a simple container for values in the application space. Usage The registry name string and registry value interface{} argument must have a non-zero value, and the registered name must be unique, otherwise an error will return. If a validator is registered, and the registry name matches any Validate.Prefix , it will be checked against Validate.Fn before the value will be added to the registry. Set import \"github.com/patrickascher/gofer/registry\" err := registry . Set ( \"Version\" , \"0.1\" ) Get import \"github.com/patrickascher/gofer/registry\" value , err := registry . Get ( \"Version\" ) // Output value // 0.1 Prefix Prefix will return all entries which name starts with the given prefix. import \"github.com/patrickascher/gofer/registry\" err := registry . Set ( \"export_json\" , \"\" ) values := registry . Prefix ( \"export_\" ) //... Validator Because of the value type interface{} , any type can be registered as value. Sometimes it makes sense to check the value before its getting added (e.g. against a type). The Validator function requires a Validate struct as argument. It must be defined with Validate.Prefix string and Validate.Fn func(name string, value interface{}) error . The Validate.Prefix must be unique, otherwise an error will return. The Validate.Fn will receive the registry name and registry value as arguments. Now before any value will be added to the registry, it will be checked against the Validate.Fn if the registry name matches the Validate.Prefix . import \"github.com/patrickascher/gofer/registry\" err = registry . Validator ( registry . Validate { Prefix : \"test_\" , Fn : func ( name string , value interface {}) error { if reflect . TypeOf ( value ). Kind () != reflect . String { return errors . New ( \"wrong type\" ) } return nil }}) //... // test_foo matches the registeres prefix test_. // The custom type check is ok. err := registry . Set ( \"test_foo\" , \"ok\" ) //... // test_bar matches the registeres prefix test_. // The custom type check throws an error, because its no string. err := registry . Set ( \"test_bar\" , false ) // ... Examples Type casting You can add any type as value, as long as it is not nil. In the following example we are going to add a function as value. !!! tip If you are adding a function as reference (without braces), the variables/objects of the function will only be allocated on function call. Like this, the memory will only be allocated, when needed! import \"github.com/patrickascher/gofer/registry\" type Config struct { Debug bool } // The function we are going to add func Debug ( cfg Config ) bool { return cfg . Debug } // set the new registry \"dummyFunc\" with the function as reference err := registry . Set ( \"dummyFunc\" , New ) //... // getting the \"dummyFunc\" registry fn , err := registry . Get ( \"dummyFunc\" ) //... // casting the function and call it with the config argument output = fn .( func ( Config ) bool )( Config { Debug : true }) // output: true","title":"Registry"},{"location":"reference/go/registry/#registry","text":"Package registry provides a simple container for values in the application space.","title":"Registry"},{"location":"reference/go/registry/#usage","text":"The registry name string and registry value interface{} argument must have a non-zero value, and the registered name must be unique, otherwise an error will return. If a validator is registered, and the registry name matches any Validate.Prefix , it will be checked against Validate.Fn before the value will be added to the registry.","title":"Usage"},{"location":"reference/go/registry/#set","text":"import \"github.com/patrickascher/gofer/registry\" err := registry . Set ( \"Version\" , \"0.1\" )","title":"Set"},{"location":"reference/go/registry/#get","text":"import \"github.com/patrickascher/gofer/registry\" value , err := registry . Get ( \"Version\" ) // Output value // 0.1","title":"Get"},{"location":"reference/go/registry/#prefix","text":"Prefix will return all entries which name starts with the given prefix. import \"github.com/patrickascher/gofer/registry\" err := registry . Set ( \"export_json\" , \"\" ) values := registry . Prefix ( \"export_\" ) //...","title":"Prefix"},{"location":"reference/go/registry/#validator","text":"Because of the value type interface{} , any type can be registered as value. Sometimes it makes sense to check the value before its getting added (e.g. against a type). The Validator function requires a Validate struct as argument. It must be defined with Validate.Prefix string and Validate.Fn func(name string, value interface{}) error . The Validate.Prefix must be unique, otherwise an error will return. The Validate.Fn will receive the registry name and registry value as arguments. Now before any value will be added to the registry, it will be checked against the Validate.Fn if the registry name matches the Validate.Prefix . import \"github.com/patrickascher/gofer/registry\" err = registry . Validator ( registry . Validate { Prefix : \"test_\" , Fn : func ( name string , value interface {}) error { if reflect . TypeOf ( value ). Kind () != reflect . String { return errors . New ( \"wrong type\" ) } return nil }}) //... // test_foo matches the registeres prefix test_. // The custom type check is ok. err := registry . Set ( \"test_foo\" , \"ok\" ) //... // test_bar matches the registeres prefix test_. // The custom type check throws an error, because its no string. err := registry . Set ( \"test_bar\" , false ) // ...","title":"Validator"},{"location":"reference/go/registry/#examples","text":"","title":"Examples"},{"location":"reference/go/registry/#type-casting","text":"You can add any type as value, as long as it is not nil. In the following example we are going to add a function as value. !!! tip If you are adding a function as reference (without braces), the variables/objects of the function will only be allocated on function call. Like this, the memory will only be allocated, when needed! import \"github.com/patrickascher/gofer/registry\" type Config struct { Debug bool } // The function we are going to add func Debug ( cfg Config ) bool { return cfg . Debug } // set the new registry \"dummyFunc\" with the function as reference err := registry . Set ( \"dummyFunc\" , New ) //... // getting the \"dummyFunc\" registry fn , err := registry . Get ( \"dummyFunc\" ) //... // casting the function and call it with the config argument output = fn .( func ( Config ) bool )( Config { Debug : true }) // output: true","title":"Type casting"},{"location":"reference/go/router/","text":"Router Package router provides a manager to add public and secure routes based on a http.Handler or http.HandlerFunc . Specific Action<->HTTP Method mapping can be defined. Middleware can be added for each route or globally for all secured routes. Files or directories can be added. The PATTERN , PARAMS , ACTION and ( ALLOWED HTTP Methods - only on OPTIONS) will be added as request context. Usage Inspired by the database/sql , this module is based on providers. You have to import the needed provider with a dash in front: This will only call the init function(s) of the package(s) and will register itself. For a full list of all available providers, see the providers section . import \"github.com/patrickascher/gofer/router\" import _ \"github.com/patrickascher/gofer/router/httprouter\" // example for the julienschmidt http router New The New function requires two arguments. First the name of the registered provider and a provider configuration. Each provider will have different configuration settings, please see the providers section for more details. // get a new router instance. routerManager , err := router . New ( router . JSROUTER , nil ) AllowHTTPMethod Can be used to disable one or more HTTP methods globally. By Default: TRACE and CONNECT are disabled. // will disable globally HTTP GET for any routes. err = routerManager . AllowHTTPMethod ( http . MethodGet , false ) SetSecureMiddleware Middleware(s) can be added. They will automatically apply to the AddSecureRoute (s). routerManager . SetSecureMiddleware ( mw ) SetFavicon Sets the fav icon. The pattern is /favicon.ico . If the source does not exist, an error will return. err := routerManager . SetFavicon ( \"assets/img/favicon.ico\" ) AddPublicFile The first argument is the pattern, and the second one is the source. The pattern must begin with a / . If the pattern already exists, or the source does not exist, an error will return. err := routerManager . AddPublicFile ( \"/robot.txt\" , \"assets/static/robot.txt\" ) AddPublicDir The first argument is the pattern, and the second one is the source. Directories are not allowed on pattern root level / . The pattern must begin with a / . If the pattern already exists, or the source does not exist, an error will return. err := routerManager . AddPublicDir ( \"/images\" , \"assets/img\" ) AddPublicRoute A route can be added to the router. Please see the route section for more details. err := routerManager . AddPublicRoute ( router . NewRoute ( \"/login\" , handleFunc )) AddSecureRoute A secure route can be added to the router. Please see the route section for more details. The route secure variable will be set to true If no secure middleware(s) are defined, an error will return. err := routerManager . AddSecureRoute ( router . NewRoute ( \"/admin\" , handleFunc )) Routes All defined routes of the router will return. routes := routerManager . Routes () RouteByPattern The route by the given pattern will return. If the pattern does not exist, an error will return. routes := routerManager . RouteByPattern ( \"/favicon.ico\" ) Handler Returns the http.Handler . handler := routerManager . Handler () SetNotFound Set a custom handler for all routes which can not be found. routerManager . SetNotFound ( hanlder ) Route A new route can be created with router.NewRoute(pattern string, handler interface{}, mapping ...Mapping) . patter : If the pattern already exists, an error will return. handler can be of type http.Handler or http.HandlerFunc . If it is nil or any other type, an error will return. A action name mapping is required on http.Handler . Mappings can be defined optionally on http.HandlerFunc . By default, all allowed HTTP methods of the router, will be mapped. A Mapping instance can be created with router.NewMapping(methods []string, action interface{}, mw *middleware) . The methods are any HTTP methods which should be mapped to the pattern. If its nil, all allowed HTTP methods of the router manager will be added. The action can be of the type string or func . If the type is func , the function name will be set as string on runtime. The action string will be added as request context. If set, the middlewares will be added to the route. For each pattern, any HTTP method must be unique, otherwise an error will return. route := router . NewRoute ( \"/public2\" , handleFunc , router . NewMapping ([] string { http . MethodGet }, \"View\" , nil ), router . NewMapping ([] string { http . MethodPUt }, \"Create\" , nil )) Middleware All pre-defined middleware: Logger Provides a middleware for the logger.Manager . The logged information is remoteAddr, HTTP Method, URL, Proto, HTTP Status, Response size and requested time. On HTTP status < 400 a log.Info() will be called otherwise log.Error() . !!!Info The logger middleware should used before all other middlewares, otherwise the request time will be incorrect. // the middleware mw := router . NewMiddleware ( middleware . NewLogger ( logManager ). MW ) JWT Provides a middleware to check against a JWT token. If the JWT token is invalid a http.StatusUnauthorized will return. If the JWT token is expired it will be re-generated if allowed. In such case, the request header will be manipulated if a refresh happens, so that there is the new refresh token as REFRESH cookie and the old one as REFRESH_OLD . There are two callback functions. CallbackGenerate for manipulating the claim before its signed. CallbackRefresh to check if the refresh token is still valid, against a custom logic. The claim will be set as request context with the key jwt.CLAIM . A claim struct is provided and can be embedded into a custom struct. cfg := jwt . Config { Alg : jwt . HS512 , Issuer : \"authserver\" , Audience : \"client\" , Subject : \"auth\" , Expiration : 5 * time . Minute , SignKey : \"secret\" , RefreshToken : jwt . RefreshConfig { Expiration : 30 * 24 * time . Hour } } claim := jwt . Claim {} jwt := jwt . New ( cfg , claim ); jwt . CallbackRefresh = func ( http . ResponseWriter , * http . Request , Claimer ){ return nil } // your logic jwt . CallbackGenerate = func ( http . ResponseWriter , * http . Request , Claimer ){ return nil } // your logic // the middleware mw := router . NewMiddleware ( jwt . MW ) RBAC Provides a role based access control list. It is build on top of the JWT middleware. A RoleService must be set, to check against the custom logic. Simply implement the RoleService interface. The arguments pattern HTTP method and claim will be passed to the Allowed function. !!!Info The JWT middleware must be set before the RBAC middleware. roleService := CustomService {}; rbac := middleware . NewRbac ( roleService ) // the middleware mw := router . NewMiddleware ( jwt . MW , rbac . MW ) Providers All pre-defined providers: JSROUTER A wrapper for httprouter . Name: router.JSROUTER Options: no options are available at the moment. Usage: import \"github.com/patrickascher/gofer/router\" import _ \"github.com/patrickascher/gofer/router/jsrouter\" r , err := router . New ( router . JSROUTER , nil ) Create your own provider To create your own provider, you have to implement the router.Provider interface. // Provider interface. type Provider interface { // Handler must return the mux for http/server. Handler () http . Handler // custom NotFound handler can be set. SetNotFound ( http . Handler ) // AddRoute to the router. AddRoute ( Route ) error // AddPublicDir to the router. // The source is already checked if it exists. AddPublicDir ( url string , path string ) error // AddPublicFile to the router // The source is already checked if it exists. AddPublicFile ( url string , path string ) error } Use the init function to register your provider. The registered value must be of the type func(m Manager, options interface{}) (router.Provider, error) . // init register your config provider func init () { //... err := router . Register ( \"my-provider\" , New ) if err != nil { log . Fatal ( err ) } } func New ( m Manager , options interface {}) ( router . Provider , error ){ //... return provider , nil } Usage import \"github.com/patrickascher/gofer/router\" import _ \"your/repo/router/yourProvider\" err := router . New ( \"my-provider\" , options )","title":"Router"},{"location":"reference/go/router/#router","text":"Package router provides a manager to add public and secure routes based on a http.Handler or http.HandlerFunc . Specific Action<->HTTP Method mapping can be defined. Middleware can be added for each route or globally for all secured routes. Files or directories can be added. The PATTERN , PARAMS , ACTION and ( ALLOWED HTTP Methods - only on OPTIONS) will be added as request context.","title":"Router"},{"location":"reference/go/router/#usage","text":"Inspired by the database/sql , this module is based on providers. You have to import the needed provider with a dash in front: This will only call the init function(s) of the package(s) and will register itself. For a full list of all available providers, see the providers section . import \"github.com/patrickascher/gofer/router\" import _ \"github.com/patrickascher/gofer/router/httprouter\" // example for the julienschmidt http router","title":"Usage"},{"location":"reference/go/router/#new","text":"The New function requires two arguments. First the name of the registered provider and a provider configuration. Each provider will have different configuration settings, please see the providers section for more details. // get a new router instance. routerManager , err := router . New ( router . JSROUTER , nil )","title":"New"},{"location":"reference/go/router/#allowhttpmethod","text":"Can be used to disable one or more HTTP methods globally. By Default: TRACE and CONNECT are disabled. // will disable globally HTTP GET for any routes. err = routerManager . AllowHTTPMethod ( http . MethodGet , false )","title":"AllowHTTPMethod"},{"location":"reference/go/router/#setsecuremiddleware","text":"Middleware(s) can be added. They will automatically apply to the AddSecureRoute (s). routerManager . SetSecureMiddleware ( mw )","title":"SetSecureMiddleware"},{"location":"reference/go/router/#setfavicon","text":"Sets the fav icon. The pattern is /favicon.ico . If the source does not exist, an error will return. err := routerManager . SetFavicon ( \"assets/img/favicon.ico\" )","title":"SetFavicon"},{"location":"reference/go/router/#addpublicfile","text":"The first argument is the pattern, and the second one is the source. The pattern must begin with a / . If the pattern already exists, or the source does not exist, an error will return. err := routerManager . AddPublicFile ( \"/robot.txt\" , \"assets/static/robot.txt\" )","title":"AddPublicFile"},{"location":"reference/go/router/#addpublicdir","text":"The first argument is the pattern, and the second one is the source. Directories are not allowed on pattern root level / . The pattern must begin with a / . If the pattern already exists, or the source does not exist, an error will return. err := routerManager . AddPublicDir ( \"/images\" , \"assets/img\" )","title":"AddPublicDir"},{"location":"reference/go/router/#addpublicroute","text":"A route can be added to the router. Please see the route section for more details. err := routerManager . AddPublicRoute ( router . NewRoute ( \"/login\" , handleFunc ))","title":"AddPublicRoute"},{"location":"reference/go/router/#addsecureroute","text":"A secure route can be added to the router. Please see the route section for more details. The route secure variable will be set to true If no secure middleware(s) are defined, an error will return. err := routerManager . AddSecureRoute ( router . NewRoute ( \"/admin\" , handleFunc ))","title":"AddSecureRoute"},{"location":"reference/go/router/#routes","text":"All defined routes of the router will return. routes := routerManager . Routes ()","title":"Routes"},{"location":"reference/go/router/#routebypattern","text":"The route by the given pattern will return. If the pattern does not exist, an error will return. routes := routerManager . RouteByPattern ( \"/favicon.ico\" )","title":"RouteByPattern"},{"location":"reference/go/router/#handler","text":"Returns the http.Handler . handler := routerManager . Handler ()","title":"Handler"},{"location":"reference/go/router/#setnotfound","text":"Set a custom handler for all routes which can not be found. routerManager . SetNotFound ( hanlder )","title":"SetNotFound"},{"location":"reference/go/router/#route","text":"A new route can be created with router.NewRoute(pattern string, handler interface{}, mapping ...Mapping) . patter : If the pattern already exists, an error will return. handler can be of type http.Handler or http.HandlerFunc . If it is nil or any other type, an error will return. A action name mapping is required on http.Handler . Mappings can be defined optionally on http.HandlerFunc . By default, all allowed HTTP methods of the router, will be mapped. A Mapping instance can be created with router.NewMapping(methods []string, action interface{}, mw *middleware) . The methods are any HTTP methods which should be mapped to the pattern. If its nil, all allowed HTTP methods of the router manager will be added. The action can be of the type string or func . If the type is func , the function name will be set as string on runtime. The action string will be added as request context. If set, the middlewares will be added to the route. For each pattern, any HTTP method must be unique, otherwise an error will return. route := router . NewRoute ( \"/public2\" , handleFunc , router . NewMapping ([] string { http . MethodGet }, \"View\" , nil ), router . NewMapping ([] string { http . MethodPUt }, \"Create\" , nil ))","title":"Route"},{"location":"reference/go/router/#middleware","text":"All pre-defined middleware:","title":"Middleware"},{"location":"reference/go/router/#logger","text":"Provides a middleware for the logger.Manager . The logged information is remoteAddr, HTTP Method, URL, Proto, HTTP Status, Response size and requested time. On HTTP status < 400 a log.Info() will be called otherwise log.Error() . !!!Info The logger middleware should used before all other middlewares, otherwise the request time will be incorrect. // the middleware mw := router . NewMiddleware ( middleware . NewLogger ( logManager ). MW )","title":"Logger"},{"location":"reference/go/router/#jwt","text":"Provides a middleware to check against a JWT token. If the JWT token is invalid a http.StatusUnauthorized will return. If the JWT token is expired it will be re-generated if allowed. In such case, the request header will be manipulated if a refresh happens, so that there is the new refresh token as REFRESH cookie and the old one as REFRESH_OLD . There are two callback functions. CallbackGenerate for manipulating the claim before its signed. CallbackRefresh to check if the refresh token is still valid, against a custom logic. The claim will be set as request context with the key jwt.CLAIM . A claim struct is provided and can be embedded into a custom struct. cfg := jwt . Config { Alg : jwt . HS512 , Issuer : \"authserver\" , Audience : \"client\" , Subject : \"auth\" , Expiration : 5 * time . Minute , SignKey : \"secret\" , RefreshToken : jwt . RefreshConfig { Expiration : 30 * 24 * time . Hour } } claim := jwt . Claim {} jwt := jwt . New ( cfg , claim ); jwt . CallbackRefresh = func ( http . ResponseWriter , * http . Request , Claimer ){ return nil } // your logic jwt . CallbackGenerate = func ( http . ResponseWriter , * http . Request , Claimer ){ return nil } // your logic // the middleware mw := router . NewMiddleware ( jwt . MW )","title":"JWT"},{"location":"reference/go/router/#rbac","text":"Provides a role based access control list. It is build on top of the JWT middleware. A RoleService must be set, to check against the custom logic. Simply implement the RoleService interface. The arguments pattern HTTP method and claim will be passed to the Allowed function. !!!Info The JWT middleware must be set before the RBAC middleware. roleService := CustomService {}; rbac := middleware . NewRbac ( roleService ) // the middleware mw := router . NewMiddleware ( jwt . MW , rbac . MW )","title":"RBAC"},{"location":"reference/go/router/#providers","text":"All pre-defined providers:","title":"Providers"},{"location":"reference/go/router/#jsrouter","text":"A wrapper for httprouter . Name: router.JSROUTER Options: no options are available at the moment. Usage: import \"github.com/patrickascher/gofer/router\" import _ \"github.com/patrickascher/gofer/router/jsrouter\" r , err := router . New ( router . JSROUTER , nil )","title":"JSROUTER"},{"location":"reference/go/router/#create-your-own-provider","text":"To create your own provider, you have to implement the router.Provider interface. // Provider interface. type Provider interface { // Handler must return the mux for http/server. Handler () http . Handler // custom NotFound handler can be set. SetNotFound ( http . Handler ) // AddRoute to the router. AddRoute ( Route ) error // AddPublicDir to the router. // The source is already checked if it exists. AddPublicDir ( url string , path string ) error // AddPublicFile to the router // The source is already checked if it exists. AddPublicFile ( url string , path string ) error } Use the init function to register your provider. The registered value must be of the type func(m Manager, options interface{}) (router.Provider, error) . // init register your config provider func init () { //... err := router . Register ( \"my-provider\" , New ) if err != nil { log . Fatal ( err ) } } func New ( m Manager , options interface {}) ( router . Provider , error ){ //... return provider , nil } Usage import \"github.com/patrickascher/gofer/router\" import _ \"your/repo/router/yourProvider\" err := router . New ( \"my-provider\" , options )","title":"Create your own provider"},{"location":"reference/go/server/","text":"Server Package server is a configurable webserver with pre-defined hooks. New New will create a new webserver instance. Only one webserver instance can exist. The following hooks will be called: Name Description router If a router provider is defined by config, a new router manager will be created. The Favicon, PublicDir(s) and PublicFile(s)s will be added if defined. databases All defined databases will be saved globally and opened. caches All defined caches will be created and saved globally. If the configuration Router.CreateDBRoutes is set to true , for each route an db entry will be made. cfg := server . Configuration {} //... err := server . New ( cfg ) // ... Config The server config can be embedded in your application configuration which can be passed to the New function. Error will return if this function is called before a server instance exists. type MyAppConfig struct { server . Configuration `mapstructure:\",squash\"` Name string } Within your application you can access your Config by server.Config() . You have to cast the interface to your actual type. config , err := server . Config () myConfig := config .( MyConfig ) // cast to ... ServerConfig By this function you will only receive the server.Configuration struct. Error will return if this function is called before a server instance exists. srvConfig , err := server . ServerConfig () Start Will start the webserver. Error will return if this function is called before a server instance exists. err := server . Start () // ... Stop Will stop the webserver. Error will return if this function is called before a server instance exists. err := server . Stop () // ... JWT Will return the *jwt.Token of the webserver. Error will return if this function is called before a server instance exists. jwt , err := server . JWT () // ... SetJWT Set the server jwt token.. Error will return if this function is called before a server instance exists. err := server . SetJWT ( jwt ) // ... Router Will return the defined router. Error will return if this function is called before a server instance exists. router , err := server . Router () // ... Caches Will return all defined cache managers. Error will return if this function is called before a server instance exists. caches , err := server . Databases () // ... Databases Will return all defined databases. The database is globally used and already opened. Error will return if this function is called before a server instance exists. dbs , err := server . Databases () // ...","title":"Server"},{"location":"reference/go/server/#server","text":"Package server is a configurable webserver with pre-defined hooks.","title":"Server"},{"location":"reference/go/server/#new","text":"New will create a new webserver instance. Only one webserver instance can exist. The following hooks will be called: Name Description router If a router provider is defined by config, a new router manager will be created. The Favicon, PublicDir(s) and PublicFile(s)s will be added if defined. databases All defined databases will be saved globally and opened. caches All defined caches will be created and saved globally. If the configuration Router.CreateDBRoutes is set to true , for each route an db entry will be made. cfg := server . Configuration {} //... err := server . New ( cfg ) // ...","title":"New"},{"location":"reference/go/server/#config","text":"The server config can be embedded in your application configuration which can be passed to the New function. Error will return if this function is called before a server instance exists. type MyAppConfig struct { server . Configuration `mapstructure:\",squash\"` Name string } Within your application you can access your Config by server.Config() . You have to cast the interface to your actual type. config , err := server . Config () myConfig := config .( MyConfig ) // cast to ...","title":"Config"},{"location":"reference/go/server/#serverconfig","text":"By this function you will only receive the server.Configuration struct. Error will return if this function is called before a server instance exists. srvConfig , err := server . ServerConfig ()","title":"ServerConfig"},{"location":"reference/go/server/#start","text":"Will start the webserver. Error will return if this function is called before a server instance exists. err := server . Start () // ...","title":"Start"},{"location":"reference/go/server/#stop","text":"Will stop the webserver. Error will return if this function is called before a server instance exists. err := server . Stop () // ...","title":"Stop"},{"location":"reference/go/server/#jwt","text":"Will return the *jwt.Token of the webserver. Error will return if this function is called before a server instance exists. jwt , err := server . JWT () // ...","title":"JWT"},{"location":"reference/go/server/#setjwt","text":"Set the server jwt token.. Error will return if this function is called before a server instance exists. err := server . SetJWT ( jwt ) // ...","title":"SetJWT"},{"location":"reference/go/server/#router","text":"Will return the defined router. Error will return if this function is called before a server instance exists. router , err := server . Router () // ...","title":"Router"},{"location":"reference/go/server/#caches","text":"Will return all defined cache managers. Error will return if this function is called before a server instance exists. caches , err := server . Databases () // ...","title":"Caches"},{"location":"reference/go/server/#databases","text":"Will return all defined databases. The database is globally used and already opened. Error will return if this function is called before a server instance exists. dbs , err := server . Databases () // ...","title":"Databases"},{"location":"reference/go/slicer/","text":"Slicer Package slicer providers some util functions for slices. InterfaceExists Checks if the given interface exists in a slice. If it exists, a the position and a boolean true will return slice := [] interface {}{ 1 , 2 } pos , exists := slicer . InterfaceExists ( slice , 1 ) // pos: 0, exists:true StringPrefixExists Checks if the given prefix exists in the string slice. If it exists, a slice with all matched results will return. cache := [] string { \"orm_User\" , \"orm_Address\" } result := slicer . StringPrefixExists ( cache , \"orm_\" ) // result: []string{\"orm_User\", \"orm_Address\"} StringExists Checks if the given string exists in the string slice. If it exists, the position and a boolean true will return cache := [] string { \"orm_User\" , \"orm_Address\" } result := slicer . StringPrefixExists ( cache , \"orm_User\" ) // result: 0,true StringUnique Will unique all strings in the given slice. cache := [] string { \"orm_User\" , \"orm_User\" , \"orm_Address\" } result := slicer . StringUnique ( cache // result:[]string{\"orm_User\", \"orm_Address\"}","title":"Slicer"},{"location":"reference/go/slicer/#slicer","text":"Package slicer providers some util functions for slices.","title":"Slicer"},{"location":"reference/go/slicer/#interfaceexists","text":"Checks if the given interface exists in a slice. If it exists, a the position and a boolean true will return slice := [] interface {}{ 1 , 2 } pos , exists := slicer . InterfaceExists ( slice , 1 ) // pos: 0, exists:true","title":"InterfaceExists"},{"location":"reference/go/slicer/#stringprefixexists","text":"Checks if the given prefix exists in the string slice. If it exists, a slice with all matched results will return. cache := [] string { \"orm_User\" , \"orm_Address\" } result := slicer . StringPrefixExists ( cache , \"orm_\" ) // result: []string{\"orm_User\", \"orm_Address\"}","title":"StringPrefixExists"},{"location":"reference/go/slicer/#stringexists","text":"Checks if the given string exists in the string slice. If it exists, the position and a boolean true will return cache := [] string { \"orm_User\" , \"orm_Address\" } result := slicer . StringPrefixExists ( cache , \"orm_User\" ) // result: 0,true","title":"StringExists"},{"location":"reference/go/slicer/#stringunique","text":"Will unique all strings in the given slice. cache := [] string { \"orm_User\" , \"orm_User\" , \"orm_Address\" } result := slicer . StringUnique ( cache // result:[]string{\"orm_User\", \"orm_Address\"}","title":"StringUnique"},{"location":"reference/go/stringer/","text":"Stringer Package stringer providers some util functions for strings. CamelToSnake stringer . CamelToSnake ( \"GoTestExample\" ) // returns go_test_example SnakeToCamel stringer . CamelToSnake ( \"go_test_example\" ) // returns GoTestExample Singular stringer . Singular ( \"users\" ) // returns user Plural stringer . Plural ( \"user\" ) // returns users","title":"Stringer"},{"location":"reference/go/stringer/#stringer","text":"Package stringer providers some util functions for strings.","title":"Stringer"},{"location":"reference/go/stringer/#cameltosnake","text":"stringer . CamelToSnake ( \"GoTestExample\" ) // returns go_test_example","title":"CamelToSnake"},{"location":"reference/go/stringer/#snaketocamel","text":"stringer . CamelToSnake ( \"go_test_example\" ) // returns GoTestExample","title":"SnakeToCamel"},{"location":"reference/go/stringer/#singular","text":"stringer . Singular ( \"users\" ) // returns user","title":"Singular"},{"location":"reference/go/stringer/#plural","text":"stringer . Plural ( \"user\" ) // returns users","title":"Plural"},{"location":"reference/go/structer/","text":"Structer Package structer providers some util functions for structs. ParseTag ParseTag will parse the tag to key/value pairs map[string]string . Multiple entries can be separated by ; Values are optionally. // `orm:primary` // will be parsed to: map[primary]\"\" // `orm:primary; column:id` // will be parsed to: map[column]\"id\" sfield := reflect . StructField {} structer . ParseTag ( field . Tag ( \"orm\" ))","title":"Structer"},{"location":"reference/go/structer/#structer","text":"Package structer providers some util functions for structs.","title":"Structer"},{"location":"reference/go/structer/#parsetag","text":"ParseTag will parse the tag to key/value pairs map[string]string . Multiple entries can be separated by ; Values are optionally. // `orm:primary` // will be parsed to: map[primary]\"\" // `orm:primary; column:id` // will be parsed to: map[column]\"id\" sfield := reflect . StructField {} structer . ParseTag ( field . Tag ( \"orm\" ))","title":"ParseTag"}]}